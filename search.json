[{"title":"vue之项目打包成apk","url":"/2019/12/15/vue之项目打包成apk/","content":"\n#### 1.第一步（重要）\n\n登录阿里云在远程服务器添加一个4000端口 ***\n\n修改服务器上：C:\\Windows\\System32\\drivers\\etc中的hosts文件\n\n```\n172.24.42.8     localhost\n```\n\n注意：前者：服务器内网     后者：接口运行为：localhost:4000\n\n***在服务器端运行接口：node app(localhost:4000)与第三步对应***\n\n#### 2.第二步\n\n \t修改vue.config.js中的publicPath(解决资源找不到路径问题)\n\n```\n  publicPath: process.env.NODE_ENV === 'production'\n      ? './cli-study/dist'\n      : '/'\n```\n\n#### 3.第三步\n\n打包成app不存在跨域访问的问题\n\n```\n axios.defaults.baseURL = \"http://39.105.27.132:4000\"\n 注意：39.105.27.132是服务器的公网。\n      4000后端接口的端口号\n```\n\n#### 4.第四步\n\n执行 npm run build 打包 成dist\t\n\n#### 5.第五步\n\n打开hbuilder\n\n​    1.文件+新建+移动App（项目名）\n\n​    2.把项目中除了.project 和manifest.json的所有文件删除\n\n​    3.把dist中的文件拷贝到项目中\n\n####   6.第六步\n\n 配置manifest.json文件\n\n​     修改应用信息\n\n​     修改图标配置\n\n​      修改启动图片\n\n####   7.第七步\n\n​\t打包发行\n\n​    项目右键+发行\n\n####   8.第八步\n\n​\t拷贝apk ,安装\n\n\n\n","tags":["项目打包"]},{"title":"vue之使用Apache服务器对项目进行上线","url":"/2019/11/15/vue之使用Apache服务器进行项目上线/","content":"\n#### 1.第一步\n\n项目npm run build 生成dist目录\n\n注意：把mui 中的所有svg注释掉\n\n#### 2.第二步\n\n解压Apache\n\n![img](/img/01/Apache.png) \n\n在Apache的bin目录下执行：httpd -t 查看是否出错\n\n#### 3.第三步（以下均在服务端操作）\n\n修改Apache下的conf下的httpd.conf配置文件\n\n37行 Define SRVROOT \"E:/Apache\"\n\n39行 ServerRoot \"E:/Apache\"\n\n59行 \\#Listen 12.34.56.78:80\n\n60行  Listen 8010\n\n61行   Listen 8020\n\n142行  LoadModule proxy_module modules/mod_proxy.so\n\n151行  LoadModule proxy_http_module modules/mod_proxy_http.so\n\n 225行 ServerName localhost:8888\n\n 233行 Options Indexes FollowSymLinks\n\n  234行 AllowOverride None\n\n  235行 Order allow,deny\n\n  236行 Allow from all\n\n  251行  DocumentRoot \"C:\\\\\"\n\n  252行  <Directory \"C:\\\\\">\n\n#### 4.第四步\n\n​\t把dist中的文件拷贝到E:/webapp中\n\n#### 5.第五步\n\n​    在Apache的bin目录下执行：\n\n​     安装：$ httpd.exe -k install -n \"Apache\"\n\n​\t  卸载：$ httpd.exe -k uninstall -n \"Apache\"\n\n​      Win+R: services.msc启动或停止Apache服务器。\n\n####   6.第六步\n\n​       在浏览器中输入localhost:8010查看网页显示\n\n####   7.第七步\n\n​\t\t配置Apache虚拟目录（允许Apache运行多个项目）\n\n​        509行： \\# Virtual hosts\n\n​         510行：Include conf/extra/httpd-vhosts.conf（打开）\n\n####   8.第八步(配置反向代理)\n\n```\n  <VirtualHost *:8010> \n\n  DocumentRoot \"E:/webapp\"\n\n  <Directory \"E:/webapp\">\n\n​    Options FollowSymLinks Indexes \n\n​    AllowOverride none\n\n​    Require all granted\n\n  </Directory>\n\n  Proxyrequests off\n\n  <Proxy *>\n\n​    \\#规定Deny,Allow的执行顺序, Order Deny,Allow ： 先执行Deny，再执行Allow\n\n​    Order Deny,Allow\n\n​    \\#全部禁止访问 取值：all none 指定ip\n\n​    Allow from All\n</Proxy>\n        #配置反向代理\n\t\tProxyPass /cellphone http://172.24.42.8:4000/cellphone\n\t\tProxyPass /banner http://172.24.42.8:4000/banner\n\t\tProxyPass /user http://172.24.42.8:4000/user\n\t\tProxyPass /like http://172.24.42.8:4000/like\n\t\tProxyPass /likelist http://172.24.42.8:4000/likelist\n\t\tProxyPass /search http://172.24.42.8:4000/search\n\t\tProxyPass /personalized http://172.24.42.8:4000/personalized\n\t\tProxyPass /playlist http://172.24.42.8:4000/playlist\n\t\tProxyPass /lyric http://172.24.42.8:4000/lyric\n\t\tProxyPass /top http://172.24.42.8:4000/top\n\t\tProxyPass /toplist http://172.24.42.8:4000/toplist\n\t\tProxyPass /comment http://172.24.42.8:4000/comment\n\t\tProxyPass /artist http://172.24.42.8:4000/artist\n\t\tProxyPass /artists http://172.24.42.8:4000/artists\n\t\tProxyPass /song http://172.24.42.8:4000/song\n\n</VirtualHost>\n\n<VirtualHost *:8020> \n\n  DocumentRoot \"E:/webapp1\"\n\n  <Directory \"E:/webapp1\">\n\n​    Options FollowSymLinks Indexes \n\n​    AllowOverride none\n\n​    Require all granted\n\n  </Directory>\n\n  Proxyrequests off\n\n  <Proxy *>\n\n​    \\#规定Deny,Allow的执行顺序, Order Deny,Allow ： 先执行Deny，再执行Allow\n\n​    Order Deny,Allow\n\n​    \\#全部禁止访问 取值：all none 指定ip\n\n​    Allow from All\n\n  </Proxy>\n\n​    \\#配置反向代理\n\n  ProxyPass /cats http://api.zhuishushenqi.com/cats\n\n  ProxyPass /book http://api.zhuishushenqi.com/book\n\n  ProxyPass /post http://api.zhuishushenqi.com/post\n\n  ProxyPass /ranking http://api.zhuishushenqi.com/ranking\n\n  ProxyPass /btoc http://api.zhuishushenqi.com/btoc\n\n  ProxyPass /atoc http://api.zhuishushenqi.com/atoc\n\n  ProxyPass /chapter http://chapter2.zhuishushenqi.com/chapter \n</VirtualHost>\n```\n\n注意：\n\n在C:\\Windows\\System32\\drivers\\etc的hosts中添加\n\n​        172.24.42.8(服务器ip)     smallan.top（域名）\n\n####  9.访问\n\n​\t  smllant.top:8010   smllant.top:8020\n\n####  10.解决首屏加载比较慢的问题\n\n1.打开 httpd.conf配置文件中下面两个模块的注释\n\n```\n#LoadModule deflate_module modules/mod_deflate.so\n\n#LoadModule headers_module modules/mod_headers.so\n```\n\n2.在httpd.conf配置文件最下面添加\n\n```\n<IfModule deflate_module>\n\n  SetOutputFilter DEFLATE\n\n  DeflateCompressionLevel 9\n\n</IfModule>\n```\n\n","tags":["上线"]},{"title":"vue之如何进行移动端适配","url":"/2019/11/10/vue之如何进行移动端适配/","content":"\n#### 1.在css样式兼容性方面，我们可以使用autoprefixer插件\n\n```\npostcss可以被理解为一个平台，可以让一些插件在上面跑。它提供了一个解析器，可以将CSS解析成抽象语法树。通过PostCSS这个平台，我们能够开发一些插件，来处理CSS。热门插件如autoprefixer。\n\nvue-cli已经自动集成了postcss，所以我们可以在postcss.config.js这个配置文件中直接添加autoprefixer这个插件\n```\n\n#### 2.在屏幕大小适配方面，我们可以使用下面两种方案\n\n##### （1）使用flexible和 postcss-px2rem\n\n\t之前使用rem适配的思路：使用媒体查询，确定不同屏幕下html标签的font-size  (即1rem单位)，然后在写css样式的时候，就可以使用1rem , 2rem这样的单位来做适配了。\n\t\n\t但是这种适配的问题是需要手动把px单位换算成rem单位，比较麻烦。对应的，我们可以使用flexible和 postcss-px2rem来解决这个问题\n\n```javascript\n//1.安装flexible。 flexible主要是实现在各种不同的移动端界面实现一稿搞定所有的设备兼容自适应问题\nnpm install lib-flexible --save\n\n//2.main.js引入flexible\nimport 'lib-flexible'\n\n//此时运行程序会看到html中自动加上了font-size    font-size的默认值为viewport的十分之一\n//在页面中引入flexible.js后，flexible会在<html>标签上增加一个data-dpr属性和font-size样式（如下图）。\n\n//3.安装postcss-pxtorem\nnpm install postcss-pxtorem --save-dev\n\n//4.修改postcss.config.js\nmodule.exports = {\n  plugins: {\n    //autoprefixer 自动补全css前缀的东西\n    'autoprefixer': {\n      //兼容的机型\n      browsers: ['Android >= 4.0', 'iOS >= 7']\n    },\n    'postcss-pxtorem': {\n      rootValue: 37.5, //换算基数，一般和html的font-size一致\n      propList: ['*']  //哪些css属性需要换算\n    }\n  }\n};\n```\n\n##### （2） 使用postcss-px-to-viewport\n\n\t`vw` 与 `vh`单位，以`viewport`为基准，`1vw` 与 `1vh`分别为`window.innerWidth` 与 `window.innerHeight`的百分之一。\n\t\n\tvw/vh 单位其实出现比较早了，只是以前支持性不太好，现在随着浏览器的发展，大部分（92%以上）的浏览器已经支持了vw/vh\n\n```javascript\nnpm i postcss-px-to-viewport -save -dev\n\n//修改postcss.config.js\nmodule.exports = {\n  plugins: {\n      autoprefixer: {\n          //兼容的机型\n      \t  browsers: ['Android >= 4.0', 'iOS >= 7']\n      },\n    //px转换为vw单位的插件\n    \"postcss-px-to-viewport\": {\n      //1vw = 3.2\n      viewportWidth: 320,\n      //1vh = 5.68\n      viewportHeight: 568,\n      // px to vw无法整除时，保留几位小数\n      unitPrecision: 5,\n      // 转换成vw单位   \n      viewportUnit: 'vw',\n     //不转换的类名\n      selectorBlackList: [],\n      // 小于1px不转换\n      minPixelValue: 1,\n     //允许媒体查询中转换\n      mediaQuery: false,\n      //排除node_modules文件中第三方css文件\n      exclude: /(\\/|\\\\)(node_modules)(\\/|\\\\)/  \n    },\n  }\n};\n```\n\n#### ","tags":["移动端适配"]},{"title":"vue之路由在keep-alive下的刷新问题","url":"/2019/09/24/vue之路由在keep-alive下的刷新问题/","content":"\n#### 1.keep-alive的介绍\n\n​\t\tkeep-alive是Vue的内置组件，能在组件切换过程中将状态保留在内存中，防止重复渲染DOM。\n\nkeep-alive包裹动态组件时，会缓存不活动的组件实例，而不是销毁它们。和 transition>相似，keep-alive是一个抽象组件：它自身不会渲染一个 DOM 元素，也不会出现在父组件链中\n\n#### 2.两个参数（prop)\n\n```\ninclude: 字符串或正则表达式。只有匹配的组件会被缓存。\nexclude: 字符串或正则表达式。任何匹配的组件都不会被缓存\n```\n\n#### 3.常见用法\n\n```\n// 在组件中使用\nexport default {\n  name: 'music',\n  data () {\n    return {\n    \t//excludeComponents:'music',\n        includedComponents: 'music'\n    }\n  }\n}\n```\n\n```\n<keep-alive include=\"music\">\n  <!-- 将缓存name为music的组件 -->\n  <component></component>\n</keep-alive>\n\n<keep-alive include=\"a,b\">\n  <!-- 将缓存name为a或者b的组件，结合动态组件使用 -->\n  <component :is=\"view\"></component>\n</keep-alive>\n\n<!-- 使用正则表达式，需使用v-bind -->\n<keep-alive :include=\"/a|b/\">\n  <component :is=\"view\"></component>\n</keep-alive>\n\n<!-- 动态判断 -->\n<keep-alive :include=\"includedComponents\">\n  <router-view></router-view>\n</keep-alive>\n\n<keep-alive exclude=\"test-keep-alive\">\n  <!-- 将不缓存name为test-keep-alive的组件 -->\n  <component></component>\n</keep-alive>\n```\n\n#### 4.结合router，缓存部分页面\n\n```\n使用$route.meta的keepAlive属性：\n<keep-alive>\n    <router-view v-if=\"$route.meta.keepAlive\"></router-view>\n</keep-alive>\n<router-view v-if=\"!$route.meta.keepAlive\"></router-view>\n\n```\n\n```\n需要在router中设置router的元信息meta：\n//...router.js\nexport default new Router({\n  routes: [\n    {\n      path: '/',\n      name: 'Hello',\n      component: Hello,\n      meta: {\n        keepAlive: false // 不需要缓存\n      }\n    },\n    {\n      path: '/page1',\n      name: 'Page1',\n      component: Page1,\n      meta: {\n        keepAlive: true // 需要被缓存\n      }\n    }\n  ]\n})\n```\n\n#### 5.route.meta中keepAlive属性实现其他需求\n\n    首页是A页面\n    B页面跳转到A，A页面需要缓存\n    C页面跳转到A，A页面不需要被缓存\n    \n    思路:在每个路由的beforeRouteLeave(to, from, next)钩子中设置to.meta.keepAlive\n    \n    keep-alive生命周期钩子函数：activated、deactivated\n    使用<keep-alive>会将数据保留在内存中，如果要在每次进入页面的时候获取最新的数据，需要在activated阶段获取数据，承担原来created钩子中获取数据的任务。\n\nA的路由：\n\n```\n{\n    path: '/',\n    name: 'A',\n    component: A,\n    meta: {\n        keepAlive: true // 需要被缓存\n    }\n}\nexport default {\n    data() {\n        return {};\n    },\n    methods: {},\n    beforeRouteLeave(to, from, next) {\n         // 设置下一个路由的 meta\n        to.meta.keepAlive = true;  // B 跳转到 A 时，让 A 缓存，即不刷新\n        next();\n    }\n};\nexport default {\n    data() {\n        return {};\n    },\n    methods: {},\n    beforeRouteLeave(to, from, next) {\n        // 设置下一个路由的 meta\n        to.meta.keepAlive = false; // C 跳转到 A 时让 A 不缓存，即刷新\n        next();\n    }\n};\n```","tags":["vue"]},{"title":"vue之使用Vant组件实现下拉刷新和上拉加载","url":"/2019/09/22/vue之使用Vant组件实现下拉刷新和上拉加载/","content":"\n#### 1.Vant的介绍\n\n​\t\tVant 是有赞开源的一套基于 Vue 2.0 的 Mobile 组件库。通过 Vant，可以快速搭建出风格统一的页面，提升开发效率。目前已有近 50 个组件，这些组件被广泛使用于有赞的各个移动端业务中。 Vant 旨在更快、更简单地开发基于 Vue 的美观易用的移动站点\n\n#### 2.下拉刷新和上拉加载的实现\n\n（1）通过 npm 安装\n\n```\nnpm i vant -S\n```\n\n#### 3.在babel.config.js中配置\n\n```\n安装插件：\nnpm i babel-plugin-import -D\n```\n\n```\n添加配置：\n在 babel.config.js 中配置\nmodule.exports = {\n  plugins: [\n    ['import', {\n      libraryName: 'vant',\n      libraryDirectory: 'es',\n      style: true\n    }, 'vant']\n  ]\n};\n```\n\n#### 4.在main.js中引入样式表\n\n```\nimport 'vant/lib/index.css'\n```\n\n#### 5.在组件简单使用\n\n```\n<template>\n  <div class=\"contain\">\n    <van-pull-refresh v-model=\"isLoading\" @refresh=\"onRefresh\">\n      <van-list v-model=\"loading\" :finished=\"finished\" finished-text=\"没有更多了\" @load=\"onLoad\">\n        <van-cell v-for=\"item in list\" :key=\"item\" :title=\"item\" />\n      </van-list>\n    </van-pull-refresh>\n  </div>\n</template>\n```\n\n```\n<script>\nimport Vue from \"vue\";\nimport { List, Cell, PullRefresh } from \"vant\";\nimport { Toast } from \"vant\";\nVue.use(List);\nVue.use(Cell);\nVue.use(PullRefresh);\n\nexport default {\n  data: function() {\n    return {\n      list: [],\n      loading: false,\n      finished: false,\n      isLoading: false\n    };\n  },\n  methods: {\n    //返回\n    returnbtn() {\n      this.$router.go(-1);\n    },\n    // 上拉加载\n    onLoad() {\n      // 异步更新数据\n      // setTimeout 仅做示例，真实场景中一般为 ajax 请求\n      setTimeout(() => {\n        for (let i = 0; i < 20; i++) {\n          this.list.push(this.list.length + 1);\n        }\n        // 加载状态结束\n        this.loading = false;\n        // 数据全部加载完成\n        if (this.list.length >= 140) {\n          this.finished = true;\n        }\n      }, 1000);\n    },\n    // 下拉刷新\n    onRefresh() {\n      setTimeout(() => {\n        Toast(\"刷新成功\");\n        this.isLoading = false;\n        this.list = [];\n        this.finished = false;\n        for (let i = 0; i < 20; i++) {\n          this.list.push(this.list.length + 1);\n        }\n      }, 1000);\n    }\n  }\n};\n</script>\n```\n\n#### 6.在实际项目中的使用\n\n    <template>\n      <div class=\"contain\">\n        <div class=\"backimg\">\n          <i class=\"iconfont icon-zuojiantou\" @click=\"returnbtn()\" />\n          <div class=\"backimg-wenzi\">评论</div>\n        </div>\n        <van-pull-refresh v-model=\"isLoading\" @refresh=\"onRefresh\">\n          <van-list v-model=\"loading\" :finished=\"finished\" finished-text=\"没有更多了\" @load=\"onLoad\">\n            <div class=\"hotcomments\">\n              <h4>最新评论------{{total}}</h4>\n              <div class=\"hotcom\" v-for=\"(item,index) in commentsLists\" :key=\"index\">\n                <div class=\"hotcomimg\">\n                  <img v-lazy=\"item.user.avatarUrl\" alt />\n                  <div class=\"nickname\">\n                    {{item.user.nickname}}\n                    <br />\n                    {{item.time | dateFormat('HH:mm')}}\n                  </div>\n                  <div class=\"lickedcount\">\n                    {{item.likedCount}}\n                    <i class=\"iconfont icon-dianzan\" />\n                  </div>\n                </div>\n                <div class=\"content\">{{item.content}}</div>\n              </div>\n            </div>\n          </van-list>\n        </van-pull-refresh>\n      </div>\n    </template>\n    \n    <script>\n    import Vue from \"vue\";\n    import { List, Cell, PullRefresh } from \"vant\";\n    import { Toast } from \"vant\";\n    Vue.use(List);\n    Vue.use(Cell);\n    Vue.use(PullRefresh);\n    \n    import myaxios, {\n      getCommentList,\n      postComment,\n      isPassword\n    } from \"@/tools/myaxios.js\";\n    import { mapGetters } from \"vuex\";\n    \n    export default {\n      data: function() {\n        return {\n          list: [],\n          loading: false,\n          finished: false,\n          isLoading: false,\n    \n          hotCommentsLists: [],\n          commentsLists: [],\n          total: 0, //总共的数据条数\n          text: \"\",\n          page: 1, //请求第几页\n          pageSize: 10, //每页请求的数量\n          total: 0 //总共的数据条数\n        };\n      },\n      async created() {\n        //创建组件时，加载第1页数据\n        this.getList();\n      },\n      methods: {\n        //返回\n        returnbtn() {\n          this.$router.go(-1);\n        },\n        // 上拉加载\n        onLoad() {\n          setTimeout(() => {\n            this.page++;\n            this.getList();\n          }, 1000);\n        },\n        // 下拉刷新\n        onRefresh() {\n          setTimeout(() => {\n            Toast(\"刷新成功\");\n            this.isLoading = false;\n            this.commentsLists = [];\n            this.finished = false;\n            for (let i = 0; i < 20; i++) {\n              this.list.push(this.commentsLists.length + 1);\n            }\n          }, 1000);\n        },\n        async getList() {\n          console.log(this.$route.query.id)\n          let { data } = await myaxios(\n            \"GET\",\n            getCommentList + this.$route.query.id,\n            {\n              offset: this.page,\n              limit: this.pageSize\n            }\n          );\n          this.total = data.total;\n          this.loading = false;\n          // 返回当前页面的列表\n          let rows = data.comments;\n          if (rows == null || rows.length === 0) {\n            // 加载结束\n            this.finished = true;\n            return;\n          }\n          // 将新数据与老数据进行合并\n          this.commentsLists = this.commentsLists.concat(rows);\n          //如果列表数据条数>=总条数，不再触发滚动加载\n          if (this.commentsLists.length >= this.total) {\n            this.finished = true;\n          }\n        }\n      }\n    };\n    </script>\n    \n    <style lang=\"less\" scoped>\n    .contain {\n      //  返回\n      .backimg {\n        height: 40px;\n        line-height: 40px;\n        color: #fff;\n        .backimg-wenzi {\n          color: #fff;\n          height: 40px;\n          line-height: 40px;\n        }\n        .icon-zuojiantou {\n          font-size: 24px;\n          float: left;\n        }\n      }\n      // 评论内容\n      .hotcomments {\n        h4 {\n          color: #fff;\n        }\n        .hotcom {\n          margin: 20px;\n          color: #fff;\n          .content {\n            width: 260px;\n            margin: 0 auto;\n            //   height: 30px;\n          }\n          .hotcomimg {\n            height: 40px;\n            // border: 1px solid;\n            img {\n              float: left;\n              width: 40px;\n              height: 40px;\n              border-radius: 50%;\n            }\n            .nickname {\n              float: left;\n              margin-left: 10px;\n            }\n            .lickedcount {\n              float: right;\n            }\n          }\n        }\n      }\n    }\n    \n    .postcomment {\n      z-index: 1000;\n      position: fixed;\n      width: 100%;\n      bottom: 0px;\n      height: 50px;\n      background-color: #fff;\n    }\n    // 图片懒加载\n    img[lazy=\"loading\"] {\n      background: url(\"../../assets/images/smallant.jpg\");\n      background-size: 40px;\n    }\n    </style>\n","tags":["vue"]},{"title":"vue之moment和vuex之persistedstate","url":"/2019/09/20/vue之moment和vuex之persistedstate/","content":"\n### moment作用：时间格式化\n\n#### 1.安装\n\n```\nnpm install moment --save\n```\n\n#### 2.Main.js引入\n\n```\nimport moment from 'moment'\n\n// 定义全局的过滤器\n\nVue.filter('dateFormat', function (dataStr, pattern = \"YYYY-MM-DD HH:mm:ss\") {\n\n return moment(dataStr).format(pattern)\n\n})\n```\n\n#### 3.组件中按需使用\n\n```\nitem.time | dateFormat('mm:ss')\n```\n\n\n\n### vuex-persistedstate：解决刷新数据消失的问题\n\n####  1. 安装\n\n```\nnpm install vuex-persiste\n```\n\ndstate --savepersisitedstatepp\n\n#### 2. 引入及配置\n\n```\nimport createPersistedState from \"vuex-persistedstate\"\n\nconst store = new Vuex.Store({\n\n // ...\n\n plugins: [createPersistedState()]\n\n})\n```\n\n","tags":["vue"]},{"title":"vuex之四个辅助函数的使用","url":"/2019/09/18/vuex之四个辅助函数的使用/","content":"\n#### 1.在Store (Index.js)中定义state,mutations,actions和getters\n\n```\nimport Vue from 'vue'\nimport Vuex from 'vuex'\nimport createPersistedstate from 'vuex-persistedstate'\n\nVue.use(Vuex)\nexport default new Vuex.Store({\n  state: {\n    playList: [],\n  \n  },\n  mutations: {    \n    setPlayList(state, list) {\n      state.playList = list\n    },\n  },\n  actions: {\n    selectPlay({commit, state}, {list, index}){\n      commit('setSequenceList', list)\n      commit('setPlayList', list)\n      commit('setCurrentIndex',index)\n      commit('setPlayState', true)\n    }\n  },\n  getters: {\n    playList: function (state) {\n      return state.playList\n    },\n   \n})\n```\n\n#### 2.页面引入\n\n```\nimport { mapGetters, mapMutations, mapActions,mapState } from \"vuex\";\nexport default {\n  computed: {\n    ...mapGetters([\n      \"playList\",  \n]),\nmethods: {\n    ...mapMutations({\n       setPlayList: \"setPlayList\"\n    }),\n    ...mapActions([\"selectPlay\"])\n  },\n}\n```\n\n####  3.页面直接使用\n\n```\nthis.playList\nthis.setPlayList(songlist);\nthis.selectPlay({\n          list: this.recommondLists,\n          index\n        })\n    },\n```\n\n```\n...mapGetters和mapState在computed中使用\n...mapAction和mapMutation 在methods中使用\n```\n\n","tags":["vuex"]},{"title":"前端安全性有关问题","url":"/2019/08/17/前端安全性的有关问题/","content":"\n* [XSS](#XSS)\n* [CSRF](#CSRF)\n\n#### XSS\n\n###### XSS是什么\n\n​\t\tXSS是一种经常出现在web应用中的计算机安全漏洞，它允许恶意web用户将代码植入到提供给其它用户使用的页面中。<br>\n比如这些代码包括HTML代码和客户端脚本。攻击者利用XSS漏洞旁路掉访问控制——例如同源策略(same origin policy)。<br>\n这种类型的漏洞由于被黑客用来编写危害性更大的网络钓鱼(Phishing)攻击而变得广为人知。<br>\n对于跨站脚本攻击，黑客界共识是：跨站脚本攻击是新型的“缓冲区溢出攻击“，而JavaScript是新型的“ShellCode”。\n\n```\n示例：\n<script>alert(document.cookie)</script>\n```\n\n###### 特点\n\n​\t\t能注入恶意的HTML/JavaScript代码到用户浏览的网页上，从而达到Cookie资料窃取、会话劫持、钓鱼欺骗等攻击。\n<攻击代码不一定（非要）在 <script></script> 中>\n\n###### 原因\n\n* Web浏览器本身的设计不安全。浏览器能解析和执行JS等代码，但是不会判断该数据和程序代码是否恶意。\n* 输入和输出是Web应用程序最基本的交互，而且网站的交互功能越来越丰富。如果在这过程中没有做好安全防护，很容易会出现XSS漏洞。\n* 程序员水平参差不齐，而且大都没有过正规的安全培训，没有相关的安全意识。\n* XSS攻击手段灵活多变。\n\n###### 危害\n\n* 盗取各类用户帐号，如机器登录帐号、用户网银帐号、各类管理员帐号\n* 控制企业数据，包括读取、篡改、添加、删除企业敏感数据的能力\n* 盗窃企业重要的具有商业价值的资料\n* 非法转账\n* 强制发送电子邮件\n* 网站挂马\n* 控制受害者机器向其它网站发起攻击\n\n###### 如何防范\n\n* 将重要的cookie标记为http only, 这样的话Javascript 中的document.cookie语句就不能获取到cookie了.\n* 表单数据规定值的类型，例如：年龄应为只能为int、name只能为字母数字组合。。。。\n* 对数据进行Html Encode 处理\n* 过滤或移除特殊的Html标签， 例如: <script>, <iframe> , &lt; for <, &gt; for >, &quot for\n* 过滤JavaScript 事件的标签。例如 \"onclick=\", \"onfocus\" 等等。\n\n参考资料：<br>\nhttps://www.cnblogs.com/phpstudy2015-6/p/6767032.html<br>\nhttps://www.cnblogs.com/443855539-wind/p/6055816.html<br>\nhttps://baike.baidu.com/item/XSS%E6%94%BB%E5%87%BB/954065?fr=aladdin\n\n\n#### CSRF\n\nCSRF（Cross-site request forgery）跨站请求伪造，也被称为“One Click Attack”或者Session Riding，通常缩写为CSRF或者XSRF，是一种对网站的恶意利用。尽管听起来像跨站脚本（XSS），但它与XSS非常不同，XSS利用站点内的信任用户，而CSRF则通过伪装来自受信任用户的请求来利用受信任的网站。与XSS攻击相比，CSRF攻击往往不大流行（因此对其进行防范的资源也相当稀少）和难以防范，所以被认为比XSS更具危险性。\n\n###### 特点\n\n* 依靠用户标识危害网站\n* 利用网站对用户标识的信任\n* 欺骗用户的浏览器发送HTTP请求给目标站点\n* 另外可以通过IMG标签会触发一个GET请求，可以利用它来实现CSRF攻击。\n\n###### 防御\n\n* 通过referer、token或者验证码来检测用户提交。\n* 尽量不要在页面的链接中暴露用户隐私信息。\n* 对于用户修改删除等操作最好都使用post操作 。\n* 避免全站通用的cookie，严格设置cookie的域。\n\n#####   \n\n\n\n\n\n","tags":["安全"]},{"title":"浏览器兼容性的常见问题和解决","url":"/2019/06/16/浏览器兼容性的常见问题和解决/","content":"\n#### 1.兼容性产生的原因\n\n市场上浏览器种类很多，不同浏览器的内核也不尽相同，所以各个浏览器对网页的解析存在一定的差异。\n\n#### 2.浏览器的内核\n\n浏览器内核主要分为两种，一是渲染引擎，另一个是js 引擎，内核更加倾向于说渲染引擎。\n常见的浏览器内核：\n常见的浏览器内核可以分四种：Trident、Gecko、Blink、Webkit\nIE浏览器\tTrident内核，也成为IE内核\nChrome浏览器\tWebkit内核，现在是Blink内核\nFirefox浏览器\tGecko内核，俗称Firefox内核\nSafari浏览器\tWebkit内核\nOpera浏览器\t最初是自己的Presto内核，后来加入谷歌大军，从Webkit又到了Blink内核；\n360浏览器\tIE+Chrome双内核\n猎豹浏览器\tIE+Chrome双内核\n百度浏览器\tIE内核\nQQ浏览器\tTrident（兼容模式）+Webkit（高速模式）\n\n#### 3.常见的兼容性问题\n\n1、不同浏览器的标签默认的外补丁( margin )和内补丁(padding)不同\n解决方案： css 里增加通配符 * { margin: 0; padding: 0; }\n\n2、IE6双边距问题；在 IE6中设置了float , 同时又设置margin , 就会出现边距问题\n解决方案：设置display:inline;\n\n3、当标签的高度设置小于10px，在IE6、IE7中会超出自己设置的高度\n解决方案：超出高度的标签设置overflow:hidden,或者设置line-height的值小于你的设置高度\n\n4、图片默认有间距\n解决方案：使用float 为img 布局\n\n5、IE9一下浏览器不能使用opacity\n解决方案：\nopacity: 0.5;filter: alpha(opacity = 50);filter: progid:DXImageTransform.Microsoft.Alpha(style = 0, opacity = 50);\n\n6、边距重叠问题；当相邻两个元素都设置了margin 边距时，margin 将取最大值，舍弃最小值；\n解决方案：为了不让边重叠，可以给子元素增加一个父级元素，并设置父级元素为overflow:hidden；\n\n7、cursor:hand 显示手型在safari 上不支持\n解决方案：统一使用 cursor:pointer\n\n8、两个块级元素，父元素设置了overflow:auto；子元素设置了position:relative ;且高度大于父元素，在IE6、IE7会被隐藏而不是溢出；\n解决方案：父级元素设置position:relative","tags":["兼容性"]},{"title":"React之使用Apache服务器进行项目上线","url":"/2019/05/15/React之使用Apache服务器进行项目上线 /","content":"\n#### 1.第一步\n\n在package.json里加 \"homepage\":\".\" （否则路径会发生错误）\n\n项目npm run build 生成build目录\n\n#### 2.第二步\n\n解压Apache\n\n![img](/img/01/Apache.png) \n\n在Apache的bin目录下执行：httpd -t 查看是否出错\n\n#### 3.第三步（以下均在服务器端操作）\n\n修改Apache下的conf下的httpd.conf配置文件\n\n37行 Define SRVROOT \"E:/Apache\"\n\n39行 ServerRoot \"E:/Apache\"\n\n59行 \\#Listen 12.34.56.78:80\n\n60行  Listen 8030\n\n142行  LoadModule proxy_module modules/mod_proxy.so\n\n151行  LoadModule proxy_http_module modules/mod_proxy_http.so\n\n 225行 ServerName localhost:8888\n\n 233行 Options Indexes FollowSymLinks\n\n  234行 AllowOverride None\n\n  235行 Order allow,deny\n\n  236行 Allow from all\n\n  251行  DocumentRoot \"C:\\\\\"\n\n  252行  <Directory \"C:\\\\\">\n\n#### 4.第四步\n\n​\t把build中的文件拷贝到E:/webapp中\n\n#### 5.第五步\n\n​    在Apache的bin目录下执行：\n\n​     安装：$ httpd.exe -k install -n \"Apache\"\n\n​\t  卸载：$ httpd.exe -k uninstall -n \"Apache\"\n\n​      Win+R: services.msc启动或停止Apache服务器。\n\n####   6.第六步\n\n​       在浏览器中输入localhost:8030查看网页显示\n\n####   7.第七步(可允许多个项目)\n\n​\t\t配置Apache虚拟目录（允许Apache运行多个项目）\n\n​        509行： \\# Virtual hosts\n\n​         510行：Include conf/extra/httpd-vhosts.conf（打开）\n\n####   8.第八步(配置反向代理)\n\n```\n  <VirtualHost *:8030> \n    DocumentRoot \"C:/webapp3\"\n\t<Directory \"C:/webapp3\">\n\t\tOptions FollowSymLinks Indexes \n\t\tAllowOverride none\n\t\tRequire all granted\n\t</Directory>\n\tProxyrequests off\n\t<Proxy *>\n\t\t#规定Deny,Allow的执行顺序, Order Deny,Allow ： 先执行Deny，再执行Allow\n        Order Deny,Allow\n        #全部禁止访问 取值：all none 指定ip\n        Allow from All\n\t</Proxy>\n        #配置反向代理\n\t\tProxyPass /api http://172.24.42.8:3001/api     (服务器ip)\n\t\tProxyPass /IPShare http://ip.360.cn/IPShare\t\n</VirtualHost>\n\n```\n\n注意：\n\n在C:\\Windows\\System32\\drivers\\etc的hosts中添加\n\n​             172.24.42.8(服务器ip)     smallan.top（域名）\n\n####  9.访问\n\n​\t         smllant.top:8030\n\n","tags":["上线"]},{"title":"ES6新特性之函数的新变化","url":"/2018/05/04/ES6新特性之函数的新变化/","content":"\n####  1.函数参数的扩展\n\n######  默认参数\n\n 基本用法：\n\n```\nfunction fn(name,age=17){\nconsole.log(name+\",\"+age);\n}\nfn(\"Amy\",18);  // Amy,18\nfn(\"Amy\",\"\");  // Amy,\nfn(\"Amy\");     // Amy,17\n```\n\n注意点：使用函数默认参数时，不允许有同名参数。\n\n```\n// 不报错\nfunction fn(name,name){\n console.log(name);\n}\n// 报错\n//SyntaxError: Duplicate parameter name not allowed in this context\nfunction fn(name,name,age=17){\n console.log(name+\",\"+age);\n}\n```\n\n\n只有在未传递参数，或者参数为 undefined 时，才会使用默认参数，null 值被认为是有效的值传递。\n\n```\nfunction fn(name,age=17){\n    console.log(name+\",\"+age);\n}\nfn(\"Amy\",null); // Amy,null\n函数参数默认值存在暂时性死区，在函数参数默认值表达式中，还未初始化赋值的参数值无法作为其他参数的默认值。\n\nfunction f(x,y=x){\n    console.log(x,y);\n}\nf(1);  // 1 1\n\nfunction f(x=y){\n    console.log(x);\n}\nf();  // ReferenceError: y is not defined\n```\n\n###### 不定参数\n\n不定参数用来表示不确定参数个数，形如，...变量名，由...加上一个具名参数标识符组成。具名参数只能放在参数组的最后，并且有且只有一个不定参数。\n\n基本用法\n\n```\nfunction f(...values){\n    console.log(values.length);\n}\nf(1,2);      //2\nf(1,2,3,4);  //4\n```\n\n#### 2.箭头函数\n\n箭头函数提供了一种更加简洁的函数书写方式。基本语法是：\n\n```\n参数 => 函数体\n基本用法：\nvar f = v => v;\n//等价于\nvar f = function(a){\n return a;\n}\nf(1);  //1\n```\n\n\n当箭头函数没有参数或者有多个参数，要用 () 括起来。\n\n```\nvar f = (a,b) => a+b;\nf(6,2);  //8\n```\n\n\n当箭头函数函数体有多行语句，用 {} 包裹起来，表示代码块，当只有一行语句，并且需要返回结果时，可以省略 {} , 结果会自动返回。\n\n```\nvar f = (a,b) => {\n let result = a+b;\n return result;\n}\nf(6,2);  // 8\n```\n\n\n当箭头函数要返回对象的时候，为了区分于代码块，要用 () 将对象包裹起来\n\n```\n// 报错\nvar f = (id,name) => {id: id, name: name};\nf(6,2);  // SyntaxError: Unexpected token :\n\n// 不报错\nvar f = (id,name) => ({id: id, name: name});\nf(6,2);  // {id: 6, name: 2}\n```\n\n\n注意点：没有 this、super、arguments 和 new.target 绑定。\n\n```\nvar func = () => {\n  // 箭头函数里面没有 this 对象，\n  // 此时的 this 是外层的 this 对象，即 Window \n  console.log(this)\n}\nfunc(55)  // Window \n\nvar func = () => {    \n  console.log(arguments)\n}\nfunc(55);  // ReferenceError: arguments is not defined\n```\n\n\n箭头函数体中的 this 对象，是定义函数时的对象，而不是使用函数时的对象。\n\n```\nfunction fn(){\n  setTimeout(()=>{\n    // 定义时，this 绑定的是 fn 中的 this 对象\n    console.log(this.a);\n  },0)\n}\nvar a = 20;\n// fn 的 this 对象为 {a: 19}\nfn.call({a: 18});  // 18\n```\n\n\n不可以作为构造函数，也就是不能使用 new 命令，否则会报错\n\n适合使用的场景\nES6 之前，JavaScript 的 this 对象一直很令人头大，回调函数，经常看到 var self = this 这样的代码，为了将外部 this 传递到回调函数中，那么有了箭头函数，就不需要这样做了，直接使用 this 就行。\n\n```\n// 回调函数\nvar Person = {\n    'age': 18,\n    'sayHello': function () {\n      setTimeout(function () {\n        console.log(this.age);\n      });\n    }\n};\nvar age = 20;\nPerson.sayHello();  // 20\n\nvar Person1 = {\n    'age': 18,\n    'sayHello': function () {\n      setTimeout(()=>{\n        console.log(this.age);\n      });\n    }\n};\nvar age = 20;\nPerson1.sayHello();  // 18\n```\n\n\n所以，当我们需要维护一个 this 上下文的时候，就可以使用箭头函数。\n\n不适合使用的场景\n定义函数的方法，且该方法中包含 this\n\n```\nvar Person = {\n    'age': 18,\n    'sayHello': ()=>{\n        console.log(this.age);\n      }\n};\nvar age = 20;\nPerson.sayHello();  // 20\n// 此时 this 指向的是全局对象\n\nvar Person1 = {\n    'age': 18,\n    'sayHello': function () {\n        console.log(this.age);\n    }\n};\nvar age = 20;\nPerson1.sayHello();   // 18\n// 此时的 this 指向 Person1 对象\n需要动态 this 的时候\n\nvar button = document.getElementById('userClick');\nbutton.addEventListener('click', () => {\n     this.classList.toggle('on');\n});\n```\n\n\nbutton 的监听函数是箭头函数，所以监听函数里面的 this 指向的是定义的时候外层的 this 对象，即 Window，导致无法操作到被点击的按钮对象。\n\n\n\n\n\n\n\n##### \n\n","tags":["ES6"]},{"title":"ES6新特性之解决异步问题的方案","url":"/2018/05/03/ES6新特性之解决异步问题的方案/","content":"\n####  1.使用回调函数解决异步问题\n\n```\nfunction eat(callback){\n    console.log(\"吃饭\");\n    setTimeout(() => {\n        callback();\n    }, 3000);\n}\n\nfunction sing(){\n    console.log(\"唱歌\")\n}\n\neat(sign);\n```\n\n#### 2.使用Promise解决异步问题\n\n```\nnew Promise(function (resolve, reject) {\n    setTimeout(() => {\n        console.log('吃饭')\n        resolve('吃好饭了')\n    }, 3000)\n}).then(function (msg) {\n    console.log(msg, '去唱歌')\n})\n```\n\n#### 3.使用async和await解决异步问题\n\n```\nasync是用来修饰方法的,加上async修饰的方法有三个作用\n1.在该方法内部可以使用await关键字\n2.该方法需要会默认返回一个Promise\n3.加async修饰的方法表示异步方法，不会堵塞当前线程的执行\n\nawait是用来等待Promise执行的结果的，await后面需要跟一个Promise\n1.可以将原来的异步变成同步任务\n2.只可以在async修饰的方法中使用\n```\n\n以读取文件为例\n\n```\nconst fs = require('fs');\n\nfunction myread(path){\n    return new Promise(function(resolve,reject){\n        fs.readFile(path,function(err,data){\n            resolve(data.toString())\n        })\n    })\n}\n\nasync function test1(){\n    //这边是堵塞了，按照串行化执行\n    let result1 =  await myread(\"./a.json\");\n    console.log(result1)\n    let result2 =  await myread(\"./b.json\");\n    console.log(result2)\n    let result3 =  await myread(\"./c.json\");\n    console.log(result3)\n}\n\ntest1()\n.then(function(msg){\n    console.log(msg)\n});\n\n```\n\n","tags":["ES6"]},{"title":"ES6新特性之Promise的介绍","url":"/2018/04/29/ES6新特性之Promise的介绍/","content":"\n####  1.Promise的概念\n\n \t\t所谓 Promise，就是一个对象，用来传递异步操作的消息。它代表了某个未来才会知道结果的事件（通常是一个异步操作），并且这个事件提供统一的 API，可供进一步处理。\n\n​\tpromise 有三个状态：\n\n```\n1.正在进行中   Pending\n2.成功          Resolved  当在promise中显示调用resolve()的时候，此时promise的状态被改变，对应promise后的then的第一个function就会执行了\n3.失败          Rejected  当在promise中显示调用reject()的时候，此时promise的状态被改变，对应promise后的then的第二个function就会执行了\n```\n\n#### 2.Promise的作用\n\n​\t\tPromise的出现主要是解决地狱回调的问题，比如你需要结果需要请求很多个接口，这些接口的参数需要另外那个的接口返回的数据作为依赖，这样就需要我们一层嵌套一层，但是有了Promise 我们就无需嵌套。\n\n​\t\t 注意：Promise本身不是异步的(Promise中的function会立马执行)，只不过Promise中可以有异步任务，当异步任务的执行有结果之后，我们通过resolve和reject来改变promise的状态，当promise的状态改变之后此时promise的then就会执行了\n\n#### 3.使用Promise读取文件举例\n\n```\nconst fs = require('fs');\nconsole.log(\"1\")   //----1\n//promise中的function是立马执行的\nvar promise = new Promise(function(resolve,reject){\n    console.log(\"2\")   //----2\n    //读取文件操作\nfs.readFile(\"./aa.json\",function(err,data){\n    console.log(\"3\");\n    //读取文件失败\n    if(err){\n        //当文件读取失败之后，会自动执行promise的then的第二个function\n        reject(\"错了,文件不存在\");\n        return;\n    }\n    //当文件读取成功之后，会自动执行promise的then的第一个function\n    resolve(data.toString())\n})\n})\npromise.then(function(msg){\n    console.log(\"4\",msg);\n},function(msg){\n    console.log(\"6\",msg);\n})\nconsole.log(\"5\") \n```\n\n#### 4.Promise链\n\n```\n  promise.then(function(){\n     return new Promise(...)\n   }).then(function(){\n     return new Promise(..)\n   }).then(function(){\n   })\n```\n\n举例\n\n```\nconsole.log(1)   \nnew Promise(function(resolve,reject){\n    console.log(2)  \n    setTimeout(() => {\n        resolve();\n    }, 2000);\n}).then(function(){\n    return new Promise(function(resolve,reject){\n        console.log(3)\n        setTimeout(() => {\n            resolve()\n        }, 2000);\n    });\n\n}).then(function(msg){\n    console.log(4,msg)\n},function(msg){\n    console.log(6,msg)\n})\nconsole.log(5) \n```\n\n当一个Promise完成（fulfilled）或者失败（rejected），返回函数将被异步调用（由当前的线程循环来调度完成）。具体的返回值依据以下规则返回：\n•\t如果then中的回调函数返回一个值，那么then返回的Promise将会成为接受状态，并且将返回的值作为接受状态的回调函数的参数值。\n•\t如果then中的回调函数没有返回值，那么then返回的Promise将会成为接受状态，并且该接受状态的回调函数的参数值为 undefined。\n•\t如果then中的回调函数抛出一个错误，那么then返回的Promise将会成为拒绝状态，并且将抛出的错误作为拒绝状态的回调函数的参数值。\n•\t如果then中的回调函数返回一个已经是接受状态的Promise，那么then返回的Promise也会成为接受状态，并且将那个Promise的接受状态的回调函数的参数值作为该被返回的Promise的接受状态回调函数的参数值。\n•\t如果then中的回调函数返回一个已经是拒绝状态的Promise，那么then返回的Promise也会成为拒绝状态，并且将那个Promise的拒绝状态的回调函数的参数值作为该被返回的Promise的拒绝状态回调函数的参数值。\n•\t如果then中的回调函数返回一个未定状态（pending）的Promise，那么then返回Promise的状态也是未定的，并且它的终态与那个Promise的终态相同；同时，它变为终态时调用的回调函数参数与那个Promise变为终态时的回调函数的参数是相同的。\n\n#### 5.Promise的异常处理\n\n```\nconst fs = require('fs');\nfunction myread(path){\n    return new Promise(function(resolve,reject){\n        fs.readFile(path,function(err,data){\n            if(err){\n                reject(err);\n                return;\n            }\n            resolve(data.toString())\n        })\n    })\n}\n\nmyread('./a.json')\n.then(function(msg){\n    console.log(msg);\n    return myread('./b.json')\n})\n.then(function(msg){\n    console.log(msg);\n    return myread('./c.json')\n})\n.then(function(msg){\n    return myread('./d.json')\n})\n.then(function(msg){\n    console.log(msg,\"aaa\")\n},function(err){\n    console.log(err,\"ddd\");\n    throw new Error(err);\n})\n.catch(function(err){\n    console.log(\"处理了异常\",err);\n})\n```\n\n\n\n#### 5.Promise.all和Promise.race\n\n举例\n\n```\nvar promise1 = new Promise(function(resolve,reject){\n    setTimeout(function(){\n        resolve(\"P1\");\n    },2000);\n})\n\nvar promise2 = new Promise(function(resolve,reject){\n    setTimeout(function(){\n        resolve(\"P2\");\n    },3000);\n})\n\n//Promise.rece([p1,p2])  promise参数数组中的任何一个promise执行完毕之后立马执行then\n//Promise.all([p1,p2]).then的函数的参数是最早执行的promise的结果\nPromise.race([promise1,promise2])\n.then(function(msg){\n    console.log(msg);\n})\n```\n\n//Promise.all([p1,p2])  会等all参数数组中的所有promise都执行完毕之后再执行then\n//Promise.all([p1,p2]).then的函数的参数是一个数组参数，会将所有promise执行的结果放到这个数组参数中\n\n//Promise.race([p1,p2])  promise参数数组中的任何一个promise执行完毕之后立马执行then\n//Promise.all([p1,p2]).then的函数的参数是最早执行的promise的结果","tags":["ES6"]},{"title":"ES6新特性之模板字面量","url":"/2018/04/28/ES6新特性之模板字面量/","content":"\n####  1.模板字面量介绍\n\n```\n模板字面量 是允许嵌入表达式的字符串字面量。你可以使用多行字符串和字符串插值功能。它们在ES2015规范的先前版本中被称为“模板字符串”。\n```\n\n####  2.模板字面量的描述\n\n模板字符串使用反引号 (` `) 来代替普通字符串中的用双引号和单引号。模板字符串可以包含特定语法（`${expression}`）的占位符。占位符中的表达式和周围的文本会一起传递给一个默认函数，该函数负责将所有的部分连接起来，如果一个模板字符串由表达式开头，则该字符串被称为带标签的模板字符串，该表达式通常是一个函数，它会在模板字符串处理后被调用，在输出最终结果前，你都可以通过该函数来对模板字符串进行操作处理。在模版字符串内使用反引号（`）时，需要在它前面加转义符（\\）。\n\n```js\n`\\`` === \"`\" // --> true\n```\n\n####  3.多行字符串\n\n在新行中插入的任何字符都是模板字符串中的一部分，使用普通字符串，你可以通过以下的方式获得多行字符串：\n\n```js\nconsole.log('string text line 1\\n' +\n'string text line 2');\n// \"string text line 1\n// string text line 2\"\n```\n\n要获得同样效果的多行字符串，只需使用如下代码：\n\n```js\nconsole.log(`string text line 1\nstring text line 2`);\n// \"string text line 1\n// string text line 2\"\n```\n\n####  4.插入表达式\n\n在普通字符串中嵌入表达式，必须使用如下语法：\n\n```js\nvar a = 5;\nvar b = 10;\nconsole.log('Fifteen is ' + (a + b) + ' and\\nnot ' + (2 * a + b) + '.');\n// \"Fifteen is 15 and\n// not 20.\"\n```\n\n现在通过模板字符串，我们可以使用一种更优雅的方式来表示：\n\n```js\nvar a = 5;\nvar b = 10;\nconsole.log(`Fifteen is ${a + b} and\nnot ${2 * a + b}.`);\n// \"Fifteen is 15 and\n// not 20.\"\n```\n\n#### 5.嵌套模板\n\n在某些时候，嵌套模板是具有可配置字符串的最简单也是更可读的方法。 在模板中，只需在模板内的占位符 `${ }` 内使用它们，就可以轻松地使用内部反引号。 例如，如果条件 a 是真的，那么返回这个模板化的文字。\n\nES5:\n\n```js\nvar classes = 'header'\nclasses += (isLargeScreen() ?\n   '' : item.isCollapsed ?\n     ' icon-expander' : ' icon-collapser');\n```\n\n在ES2015中使用模板文字而没有嵌套：\n\n```js\nconst classes = `header ${ isLargeScreen() ? '' :\n    (item.isCollapsed ? 'icon-expander' : 'icon-collapser') }`;\n```\n\n在ES2015的嵌套模板字面量中： \n\n```js\nconst classes = `header ${ isLargeScreen() ? '' :\n `icon-${item.isCollapsed ? 'expander' : 'collapser'}` }`;\n```\n\n#### 6.带标签的模板字符串\n\n更高级的形式的模板字符串是带标签的模板字符串。标签使您可以用函数解析模板字符串。标签函数的第一个参数包含一个字符串值的数组。其余的参数与表达式相关。最后，你的函数可以返回处理好的的字符串（或者它可以返回完全不同的东西 , 如下个例子所述）。用于该标签的函数的名称可以被命名为任何名字。\n\n```js\nvar person = 'Mike';\nvar age = 28;\n\nfunction myTag(strings, personExp, ageExp) {\n\n  var str0 = strings[0]; // \"that \"\n  var str1 = strings[1]; // \" is a \"\n\n  // There is technically a string after\n  // the final expression (in our example),\n  // but it is empty (\"\"), so disregard.\n  // var str2 = strings[2];\n\n  var ageStr;\n  if (ageExp > 99){\n    ageStr = 'centenarian';\n  } else {\n    ageStr = 'youngster';\n  }\n\n  return str0 + personExp + str1 + ageStr;\n\n}\n\nvar output = myTag`that ${ person } is a ${ age }`;\n\nconsole.log(output);\n// that Mike is a youngster\n```\n\n正如下面例子所展示的，标签函数并不一定需要返回一个字符串。\n\n```js\nfunction template(strings, ...keys) {\n  return (function(...values) {\n    var dict = values[values.length - 1] || {};\n    var result = [strings[0]];\n    keys.forEach(function(key, i) {\n      var value = Number.isInteger(key) ? values[key] : dict[key];\n      result.push(value, strings[i + 1]);\n    });\n    return result.join('');\n  });\n}\n\nvar t1Closure = template`${0}${1}${0}!`;\nt1Closure('Y', 'A');  // \"YAY!\" \nvar t2Closure = template`${0} ${'foo'}!`;\nt2Closure('Hello', {foo: 'World'});  // \"Hello World!\"\n```\n\n#### 7.原始字符串\n\n在标签函数的第一个参数中，存在一个特殊的属性`raw` ，我们可以通过它来访问模板字符串的原始字符串，而不经过特殊字符的替换。\n\n```js\nfunction tag(strings) {\n  console.log(strings.raw[0]);\n}\n\ntag`string text line 1 \\n string text line 2`;\n// logs \"string text line 1 \\n string text line 2\" ,\n// including the two characters '\\' and 'n'\n```\n\n另外，使用[`String.raw()`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/raw) 方法创建原始字符串和使用默认模板函数和字符串连接创建是一样的。\n\n```js\nvar str = String.raw`Hi\\n${2+3}!`;\n// \"Hi\\n5!\"\n\nstr.length;\n// 6\n\nstr.split('').join(',');\n// \"H,i,\\,n,5,!\"\n```\n\n#### 8.带标签的模版字面量及转义序列\n\n自ES2016起，带标签的模版字面量遵守以下转义序列的规则：\n\n- Unicode字符以\"\\u\"开头，例如`\\u00A9`\n- Unicode码位用\"\\u{}\"表示，例如`\\u{2F804}`\n- 十六进制以\"\\x\"开头，例如`\\xA9`\n- 八进制以\"\\\"和数字开头，例如`\\251`\n\n这表示类似下面这种带标签的模版是有问题的，因为对于每一个ECMAScript语法，解析器都会去查找有效的转义序列，但是只能得到这是一个形式错误的语法：\n\n```js\nlatex`\\unicode`\n// 在较老的ECMAScript版本中报错（ES2016及更早）\n// SyntaxError: malformed Unicode character escape sequence\n```\n\n#### 9.ES2018关于非法转义序列的修订\n\n带标签的模版字符串应该允许嵌套支持常见转义序列的语言（例如[DSLs](https://en.wikipedia.org/wiki/Domain-specific_language)、[LaTeX](https://en.wikipedia.org/wiki/LaTeX)）。ECMAScript提议[模版字面量修订](https://tc39.github.io/proposal-template-literal-revision/)(第4阶段，将要集成到ECMAScript 2018标准) 移除对ECMAScript在带标签的模版字符串中转义序列的语法限制。\n\n不过，非法转义序列在\"cooked\"当中仍然会体现出来。它们将以 [`undefined`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/undefined) 元素的形式存在于\"cooked\"之中：\n\n```js\nfunction latex(str) { \n return { \"cooked\": str[0], \"raw\": str.raw[0] }\n} \n\nlatex`\\unicode`\n\n// { cooked: undefined, raw: \"\\\\unicode\" }\n```\n\n值得注意的是，这一转义序列限制只对带标签的模板字面量移除，而不包括不带标签的模板字面量：\n\n```js\nlet bad = `bad escape sequence: \\unicode`;\n```\n\n\n\n\n\n","tags":["ES6"]},{"title":"ES6新特性之变量及解构赋值","url":"/2018/04/25/ES6新特性之变量及解构赋值/","content":"\n####  1.ES6介绍\n\n```\nECMAScript 6.0（以下简称ES6）是JavaScript语言的下一代标准，已经在2015年6月正式发布了。它的目标，是使得JavaScript语言可以用来编写复杂的大型应用程序，成为企业级开发语言。\n```\n\n####  2.关于变量\n\n###### var:\n\n1.只有全局作用域变量和函数作用域变量\n2.“变量提升”\n\n###### let:\n\n1、没有变量的提升，必须先声明后使用\n\n2、let声明的变量，不能与前面的let，var，conset声明的变量重名\n\n3、定义块级作用域变量\n\n###### const ： 定义只读变量\n\n1、const声明变量的同时必须赋值，const声明的变量必须初始化，一旦初始化完毕就不允许修改\n2、const声明变量也是一个块级作用域变量\n3、const声明的变量没有“变量的提升”，必须先声明后使用\n4、const声明的变量不能与前面的let， var ，  const声明的变量重名\n\n####  3.解构赋值\n\n###### 对象的解构赋值：\n\n```\n    //对象解构：对象解构不需要位置和数组解构位置一致，只要保证解构的变量名和属性一致即可。\n     let {a,c}={c:4,a:2};\n     console.log(a,c);\n     //如果解构失败，变量赋值为undefined.\n     let {acd}={f:2};\n     console.log(acd);\n```\n\n- 对象解构还有一个常用的功能，就是取js的一些方法，类似python的反射功能。\n\n```\n // 我们在使用对象解构的时候，可以获取对应的对象的方法类似有点想python的反射\n     let {log}=console;\n     log(222);\n      //对象解构 上面的例子都是简写形式。实际上是如下：//也就是说：a是匹配的关键字 而真正的白能量是c.\n     let {a:c}={a:2,c:4};\n     console.log(c)\n```\n\n- 对象解构嵌套解构对象，这种情况下对应嵌套的解构匹配属性不能省略。\n\n```\n   //在解构的时候，我们也可以用在解构中嵌套解构对象，也就是说可以在对象解构中嵌套数组解构 这种情况嵌套对象的属性不能省略匹配的同名属性。\n    let {ac:ac,ff:[c,a]}={ac:22,ff:[1,2]};\n    console.log(ac,c,a);\n```\n\n###### 数组的解构赋值：\n\n```\n   //解构赋值：通过数组对应，对变量进行对应赋值。\n    let [a,c,v,b]=[1,2,3,4];\n    console.log(a,c,v,b);\n    //这种赋值叫做 模式匹配。只要等号两边结构一样就可以进行赋值。\n    let [k,[[n],d]]=[1,[[2],3]];\n    console.log(k,n,d);\n    //如果解构不成功，对应变量值为undefined;\n    let [l,m]=[1];\n    console.log(m);\n    //不完全解构，如果等号左边没有全部匹配右边也是可以结构成功的。\n    let [vv,vb,vc]=[1,2,3,4];\n    console.log(vv,vb,vc);\n    //变量结构需要等号右边需要itrator结构，也就是说具备可以被迭代。否则解构不成功。\n    try {\n        // let [cc]=2;//右边并不是数组 TypeError: 2 is not iterable\n        let [dd]={};//不具备iteraor 所以解构也不成功。TypeError: {} is not iterable\n    }catch (e) {\n        console.log(e)\n    }\n```\n\n```\n// 解构允许有默认值。\n    let [a1,a2=2]=[1];\n    console.log(a1,a2);\n    // 需要注意的是在es6内部使用的是严格相等来判断一个位置是否有值。只有当数组中的成员严格等于undefined 默认值才能生效。\n    // 如果默认值里是null，因为null不严格等于undefined 所有默认值也不会生效。\n    let  [a=2]=[null];\n    console.log(a);//a=null\n    // 如果默认值是表达式，这个表达式是惰性求值。只有用到的时候才会求值。\n    fn=()=>{\n      return 2;\n    };\n    let [a=fn()]=[1];\nconsole.log(a);\n//只有a对应的右边的位置的值为undefined的时候，才会执行fn，否则不会执行相当于：\nlet x;\nx=[1][0]===undefined?fn():[1][0];//只有在对应的右边的元素为undefined的时候才会计算表达式。和函数的默认为表达式也是惰性求值。\n```\n\n```\n// 默认值也可以是其他结构解构的变量，但是对应的变量需要提前声明，否则会报错。\n    try {\n        let [ov,oc=ov]=[1];\n        console.log(ov,oc);\n        let [k1=k2,k2]=[undefined,2];\n        console.log(k1,k2);//ReferenceError: Cannot access 'k2' before initialization\n    }catch (e) {\n        console.log(e)\n    }\n```\n\n\n\n","tags":["ES6"]},{"title":"javaScript之函数的节流阀和去抖","url":"/2018/02/16/javaScript之函数的节流阀和去抖/","content":"\n#### 1.函数去抖（debounce）\n\n函数调用n秒后才会执行，如果函数在n秒内被调用的话则函数不执行，重新计算执行时间\n\n```\nfunction debounce(method,delay){\n      var timer=null;\n       return function(){\n            var context=this\n            var args=arguments;\n            clearTimeout(timer);\n            timer=setTimeout(function(){\n                method.apply(context,args);\n            },delay);\n        }\n}\n```\n\n##### 函数去抖的应用场景：\n\n1.监控键盘keypress事件，每当内容变化的时候就向服务器发送请求\n2.在页面滚动的时候监控页面的滚动事件，会频繁执行scroll事件\n3.监控页面的resize事件，拉动窗口改变大小的时候，resize事件被频繁的执行\n\n上面三种场景中都会频繁触发指定事件，比如第一种情况，每当输入框内容变化之后就向服务器发送请求，可能会导致一秒钟向服务器请求很多次，这显然是不合理的，我们可以使用函数去抖来优化。\n\n#### 2.函数节流（throttle）\n\n函数预先设定一个执行周期，当调用动作的时刻大于等于执行周期则执行该动作，然后进入下一个新周期\nfunction throttle(method,duration){\n        var  begin = new Date();\n        return function(){\n            var context = this\n            var args=arguments\n            var current=new Date();\n            if(current-begin>=duration){\n                 method.apply(context,args);\n                 begin = current;\n            }\n        }\n}\nfunction resizehandler(){\n    console.log(++n);\n}\nwindow.onresize=throttle(resizehandler,500);\n\n##### 函数节流的应用场景\n\n1.上拉下拉刷新，每拉动一次彻底完毕之后才可以下一次拉动\n2.图片轮播动画，每一张图片动画完成之后才开始下一个图片的动画\n\n\n\n\n\n\n\n","tags":["javaScript"]},{"title":"css之浮动的定义及清除浮动的方法","url":"/2017/10/10/css之浮动的定义以及清除浮动的方法/","content":"\n####   1.浮动的定义\n\n定义：使元素脱离文档流，按照指定的方向发生移动，遇到父级的边界或者相邻的浮动元素就会停下来.\n\n浮动的目的：为了达到自己的布局目的，让指定元素定位在指定位置，并且可以设置浮动后的行级元素的宽高，我们就需要用到浮动\n\n#### 2.为什么要清除浮动\n\n   清除浮动主要是为了解决，父元素因为子级元素浮动引起的内部高度为0的问题\n\n   原因：当父元素不给高度的时候，内部元素不浮动时会撑开，而浮动的时候，父元素变成一条线。\n\n#### 3.清除浮动的常用方法\n\n   （1）加空div（在最后一个浮动标签后，新加一个标签，给其设置clear：both；）（不推荐）\n\n```\n<div class=\"fahter\">\n      <div class=\"big\">big</div>\n      <div class=\"small\">small</div>\n      <div class=\"clear\">额外标签法</div>\n </div>\n```\n\n   （2）父级添加overflow属性（父元素添加overflow:hidden）（不推荐）\n\n```html\n .fahter{   \n   width: 400px; \n   border: 1px solid deeppink;\n   overflow: hidden;  \n}\n```\n\n  （3）父级使用after伪元素清除浮动（推荐使用）\n\n```html\n .clearfix:after{/*伪元素是行内元素 正常浏览器清除浮动方法*/\n        content: \"\";\n        display: block;\n        height: 0;\n        clear:both;\n        visibility: hidden;\n    }\n```\n\n  （4）使用before和after双伪元素清除浮动\n\n```html\n  .clearfix:after,.clearfix:before{\n        content: \"\";\n        display: table;\n    }\n    .clearfix:after{\n        clear: both;\n    }\n    .clearfix{\n        *zoom: 1;\n    }\n \n <div class=\"fahter clearfix\">\n        <div class=\"big\">big</div>\n        <div class=\"small\">small</div>\n    </div>\n    <div class=\"footer\"></div>\n```","tags":["css"]},{"title":"css之BFC的定义及其作用","url":"/2017/10/08/css之BFC的定义以及其作用/","content":"\n####   1.BFC的定义\n\n​    BFC即 Block Formatting Contexts (块级格式化上下文)， 是 [W3C](https://www.leiue.com/tags/w3c) [CSS](https://www.leiue.com/tags/css)2.1 规范中的一个概念。它是页面中的一块渲染区域，并且有一套渲染规则，它决定了其子元素将如何定位，以及和其他元素的关系和相互作用。\n\n#### 2.BFC的创建\n\n1. 根元素或其它包含它的元素\n2. 浮动元素 (元素的 float 不是 none)\n3. 绝对定位元素 (元素具有 position 为 absolute 或 fixed)\n4. 内联块 (元素具有 display: inline-block)\n5. 表格单元格 (元素具有 display: table-cell，HTML表格单元格默认属性)\n6. 表格标题 (元素具有 display: table-caption, HTML表格标题默认属性)\n7. 具有overflow 且值不是 visible 的块元素，\n8. display: flow-root\n9. column-span: all 应当总是会创建一个新的格式化上下文，即便具有 column-span: all 的元素并不被包裹在一个多列容器中。\n10. 一个块格式化上下文包括创建它的元素内部所有内容，除了被包含于创建新的块级格式化上下文的后代元素内的元素。\n\n#### 3.BFC布局规则\n\n   1.内部的Box会在垂直方向，一个接一个的放置\n   2.Box的垂直方向的距离由margin决定，属于同一个BFC的两个相邻的Box会重叠\n   3.BFC的区域不会与float box重叠（定位情况除外）\n   4.计算BFC的高度时，浮动元素也参与计算\n   5.BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。反之也如此\n\n####  4.BFC作用：\n\n1、解决 margin 塌陷问题\n\n​      margin塌陷问题：在标准文档流中，块级标签之间竖直方向的margin会以大的为准\n\n```\n<head>\ndiv{\n    width: 100px;\n    height: 100px;\n    background: lightblue;\n    margin: 100px;\n}\n</head>\n<body>\n    <div></div>\n    <div></div>\n</body>\n注意：两个div竖直之间的距离为100px\n```\n\n如果想要避免外边距的重叠，可以将其放在不同的 BFC 容器中\n\n```\n <div class=\"container\">\n    <p></p>\n </div>\n <div class=\"container\">\n    <p></p>\n </div>\n \n \n .container {\n    overflow: hidden;\n}\np {\n    width: 100px;\n    height: 100px;\n    background: lightblue;\n    margin: 100px;\n} \n    \n```\n\n2、避免浮动元素和其他元素重叠\n\n​     div浮动兄弟遮盖问题：左侧块级元素发生了浮动，所以和右侧未发生浮动的块级元素不在同一层内，所以会发生左边div遮挡下面的div。可以给下面div加 overflow: hidden，触发bfc来解决遮挡问题。 \n\n3、清除浮动\n\n```\n.fahter{   \n   width: 400px; \n   border: 1px solid deeppink;\n   overflow: hidden;  \n}\n```","tags":["css"]},{"title":"css3新特性之过渡动画和关键帧动画","url":"/2017/09/25/css3新特性之过渡动画和关键帧动画/","content":"\n#### 1.transition过渡动画\n\ntransition : 由一种状态到另外一种状态之间进行过渡的时候产生动画效果\n\n /* 需要添加动画的属性 不需要双引号，如果有多个属性要进行动画，中间用逗号隔开;如果该属性不写，则默认给所有属性添加动画 */   \n\n```\n transition-property: width,height;\n            /*动画的持续时间*/\n            transition-duration: 3s;\n            /*动画的运动方式*/\n            transition-timing-function: ease;\n            /*动画延迟时间*/\n            transition-delay: 1s;\n```\n\n /*复合属性*/\n\n```\n    transition: width 3s linear 0s,height 3s linear 1s;\n```\n\n\n\n#### 2.animation动画\n\nanimation：关键帧动画，一种状态到另一种状态再到另一种状态\n\n```\n .box:hover{\n            /*鼠标悬停的时候添加动画*/\n            animation-name: anim;\n            animation-duration: 4s;\n            animation-delay: 1s;\n            animation-timing-function: linear;\n            /*动画播放完的状态:forwards:保持动画播放完毕后的状态 backwards:退回到原始状态(默认值)*/\n            animation-fill-mode: forwards;\n            /*动画播放的次数*/\n            /* animation-iteration-count: 10; */\n            /*动画交叉执行*/\n            animation-direction:alternate ;\n        }\n         .box:active{\n        /*控制动画是否暂停*/\n        animation-play-state: running;\n        animation-play-state: paused;\n    }\n```\n\n   \n\n/*声明一个关键帧动画 ：我们这边只有两帧\n          动画的名字就叫：anim\n     \n\n```\n   */\n        @keyframes anim {\n            /* from{ \n                width: 100px;\n            }  \n            to{ \n                width: 300px;\n            }   */\n              0%{\n            /*可以同时对多个属性添加动画效果*/\n            transform: rotate(0deg) scale(1);\n        }\n        50%{\n            transform: rotate(180deg) scale(2);\n        }\n        100%{\n            transform: rotate(360deg) scale(1);\n        }\n    }\n```\n\n复合属性：\n\n```\n  animation: name duration timing-function delay iteration-count direction fill-mode;  \n```\n\n","tags":["动画"]},{"title":"css3新特性之弹性布局Flex","url":"/2017/09/24/css3新特性之弹性布局Flex/","content":"\n####   1.flex基本概念\n\n​\t采用Flex布局的元素，称为Flex容器（flex container），简称”容器”。它的所有子元素自动成为容器成员，称为Flex项目（flex item），简称”项目”。\n\n#### 2.容器的基本属性\n\n##### （1）flex-direction：决定主轴的方向（父级使用）\n\n​        row（默认值）：主轴为水平方向，起点在左端。\n\n​        row-reverse：主轴为水平方向，起点在右端。\n\n​        column：主轴为垂直方向，起点在上沿。\n\n​        column-reverse：主轴为垂直方向，起点在下沿。\n\n##### （2）flex-wrap：一条轴线排不下，如何换行（父级使用）\n\n​\t      nowrap(默认)：不换行\n\n​           wrap:换行，第一行在上方\n\n​           wrap-reverse:换行，第一行在下方\n\n##### （3）flex-flow：flex-flow属性是flex-direction属性和flex-wrap属性的简写形式，\n\n​         默认值为row nowrap\n\n##### （4）justify-content：项目在主轴上的对齐方式\n\n​        flex-start（默认值）：左对齐\n\n​\t\tflex-end：右对齐\n\n​\t\tcenter： 居中\n\n​\t\tspace-between：两端对齐，项目之间的间隔都相等。\n\n​\t\tspace-around：每个项目两侧的间隔相等\n\n##### （5）align-items：项目在交叉轴上如何对齐(纵轴)\n\n​         flex-start：交叉轴的起点对齐。\n\n​\t\tflex-end：交叉轴的终点对齐。\n\n​\t\tcenter：交叉轴的中点对齐。\n\n​\t\tbaseline: 项目的第一行文字的基线对齐。\n\n​\t\tstretch（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度。\n\n#####  （6）align-content：多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用\n\n​\t\tflex-start：与交叉轴的起点对齐。\n\n​\t\tflex-end：与交叉轴的终点对齐。\n\n​\t\tcenter：与交叉轴的中点对齐。\n\n​\t\tspace-between：与交叉轴两端对齐，轴线之间的间隔平均分布。\n\n​\t\tspace-around：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。\n\n​\t\tstretch（默认值）：轴线占满整个交叉轴。\n\n#### 3.项目的基本属性\n\n​\t（1）order：项目的排列顺序。数值越小，排列越靠前，默认为0\n\n​    （2）flex-grow：定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大\n\n​    （3）flex-shrink：定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。\n\n​\t（4）flex-basis：定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小。\n\n​    （5）flex：flex属性是flex-grow、flex-shrink、flex-basis的缩写，默认值为0 1 auto\n\n​\t（6）align-self：属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch","tags":["Flex布局"]},{"title":"css之水平垂直居中的四种方法","url":"/2017/09/20/css之水平垂直居中的四种方法/","content":"\n####   1.flex\n\n```\n .father {\n            display: flex;\n            justify-content: center;\n            align-items: center;\n            width: 50px;\n            height:50px;\n            border:1px solid black;\n        }\n        .son{\n            width: 30px;\n            height: 30px;\n            border: 1px solid red;\n        }\n        \n  <div class=\"father\">\n      <div class=\"son\"></div>\n  </div>\n```\n\n#### 2.position\n\n```\n .father {\n            position: relative;\n            width: 50px;\n            height: 50px;\n            border: 1px solid black;\n        }\n        .son {\n            position: absolute;\n            margin: auto;\n            top: 0;\n            bottom: 0;\n            left: 0;\n            right: 0;\n            width: 30px;\n            height: 30px;\n            border: 1px solid red;\n        }\n```\n\n\n\n#### 3.position+transform\n\n```\n.father {\n            position: relative;\n            width: 50px;\n            height: 50px;\n            border: 1px solid black;\n        }\n        .son {\n            position: absolute;\n            top: 50%;\n            left: 50%;\n            transform: translate(-50%, -50%);\n            width: 30px;\n            height: 30px;\n            border: 1px solid red;\n        }\n```\n\n\n\n####  4.table-cell\n\n```\n<style>\n        html,\n        body {\n            height: 100%;\n            width: 100%;\n            margin: 0;\n        }\n\n        .box {\n            display: table;\n            height: 100%;\n            width: 100%;\n        }\n\n        .content {\n            display: table-cell;\n            vertical-align: middle;\n            text-align: center;\n        }\n\n        .inner {\n            background-color: #000;\n            display: inline-block;\n            width: 200px;\n            height: 200px;\n        }\n    </style>\n   \n     <div class=\"box\">\n        <div class=\"content\">\n            <div class=\"inner\"></div>\n        </div>\n    </div>\n```\n\n  \n\n","tags":["css"]},{"title":"HTML5新特性","url":"/2017/09/08/HTML5新特性/","content":"\n####   1.语义化标签\n\n   　　语义化标签使得页面的内容结构化，见名知义\n\n| 标签                  |               描述               |\n| --------------------- | :------------------------------: |\n| <header></header>     |       定义了文档的头部区域       |\n| <footer></footer>     |       定义了文档的尾部区域       |\n| <nav></nav>           |          定义文档的导航          |\n| <section></section>   | 定义文档中的节（section、区段）  |\n| <article></article>   |      定义页面独立的内容区域      |\n| <aside></aside>       |       定义页面的侧边栏内容       |\n| <detailes></detailes> | 用于描述文档或文档某个部分的细节 |\n| <summary></summary>   |   标签包含 details 元素的标题    |\n| <dialog></dialog>     |      定义对话框，比如提示框      |\n\n#### 2.增强型表单\n\nHTML5 拥有多个新的表单 Input 输入类型。这些新特性提供了更好的输入控制和验证。\n\n| 输入类型       | 描述                         |\n| -------------- | ---------------------------- |\n| color          | 主要用于选取颜色             |\n| date           | 从一个日期选择器选择一个日期 |\n| datetime       | 选择一个日期（UTC 时间）     |\n| datetime-local | 选择一个日期和时间 (无时区)  |\n| email          | 包含 e-mail 地址的输入域     |\n| month          | 选择一个月份                 |\n| number         | 数值的输入域                 |\n| range          | 一定范围内数字值的输入域     |\n| search         | 用于搜索域                   |\n| tel            | 定义输入电话号码字段         |\n| time           | 选择一个时间                 |\n| url            | URL 地址的输入域             |\n| week           | 选择周和年                   |\n\n#### 3.视频和音频\n\n\n```\n<audio controls autoplay=\"autoplay\">\n    <source src=\"./mp3/aa.mp3\">   \n\n    <source src=\"./mp3/aa.wav\">   \n\n    <source src=\"./mp3/aa.ogg\"> \n\n    您的浏览器不支持音频播放功能    \n\n</audio>\n```\n\n \n\n\n```\n<video controls autoplay width=\"600px\" height=\"400px\">\n\n    <source src=\"./mp3/mp4.mp4\"/>\n\n    <source src=\"./mp3/mp4.ogg\"/>\n\n    您的浏览器不支持视频播放功能  \n\n</video>\n```\n\n#### 4.dom元素扩展\n\n​    classList 元素的样式的集合    \n\n```\na) Node.classList.add('class') 添加class    \n\nb) Node.classList.remove('class') 移除class    \n\nc) Node.classList.toggle('class') 切换class，有则移除，无则添加    \n\nd) Node.classList.contains('class')检测是否存在class   \n```\n\n#### 5.  本地存储\n\n​       sessionStorage的使用：存储数据到本地。存储的容量5mb左右。  \n\n​        1.这个数据本质是存储在当前页面的内存中-意味着新开的页面和新开的浏览器无法获取数据 \n\n​        2.它的生命周期为关闭当前页面，关闭页面，数据会自动清除         \n\n​        3.如果当前页面显示的内容发生改变之后，sessionStorage数据仍然在 \n\n​                  setItem(key,value):存储数据，以键值对的方式存储        \n\n​                  getItem(key):获取数据，通过指定名称的key获取对应的value值     \n\n​                  removeItem(key):删除数据，通过指定名称key删除对应的值      \n\n​                  clear():清空所有存储的内容           \n\n​       localStorage的使用：  存储的内容大概20mb  不同浏览器不能共享数据。但是在同一个浏览器的不同窗口中可以共享数据  永久生效，它的数据是存储在硬盘上，并不会随着页面或者浏览器的关闭而清除.如果想清除，必须手动清除  \n\n​               setItem(key,value):存储数据，以键值对的方式存储  \n\n​               getItem(key):获取数据，通过指定名称的key获取对应的value值\n\n​               removeItem(key):删除数据，通过指定名称key删除对应的值  \n\n​               clear():清空所有存储的内容          \n\n​              sessionStorage 和 localStorage在存和取的时候操作的都是字符串     \n\n","tags":["HTML5"]},{"title":"动画demo通过github访问","url":"/2016/11/20/动画demo通过github搭建访问/","content":"\n#### **1.**  新建一个远程仓库\n\n![img](/img/01/wps1.jpg) \n\n#### 2. 在animations仓库setting中随意选择一个主题\n\n![img](/img/01/wps2.jpg) \n\n#### 3. 通过仓库的首页\n\n   通过 https://smallantcxq.github.io/animations/可访问：\n\n![img](/img/01/wps3.jpg) \n\n\n\n如下：\n\n![img](/img/01/wps4.jpg) \n\n#### 4. 在本地创建文件夹空文件夹（animat）映射仓库\n\n 在animat中打开git Bash命令行\n\ngit clone git@github.com:smallAntcxq/animations.git\n\n#### 5. 删除animat中的除.git文件外的所有文件(.git为隐藏文件)\n\n在此路径下执行\n\n$ git add *\n\n$ git commit -m 'del'\n\n$ git push origin master\n\n这时执行 https://smallantcxq.github.io/animations/显示404\n\n#### 6. 在animations中加入想要展示的页面\n\n![img](/img/01/wps5.jpg) \n\n执行：\n\n$ git add *\n\n$ git commit -m 'del'\n\n$ git push origin master\n\n#### 7. 结果为：\n\n![img](/img/01/wps6.jpg)\n\n#### 8. 这时通过以下可访问\n\nhttps://smallantcxq.github.io/animations/3d.html\n\nhttps://smallantcxq.github.io/animations/sky.html\n\nhttps://smallantcxq.github.io/animations/game.html","tags":["搭建步骤"]}]