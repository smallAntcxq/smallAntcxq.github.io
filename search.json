[{"title":"动态添加删除表单","url":"/2020/12/20/vue使用动态添加表单及校验/","content":"\n#### 1.动态添加表单及校验\n\n```\n<template>\n  <a-form-model\n    ref=\"refForm\"\n    :model=\"form\"\n    :label-col=\"labelCol\"\n    :wrapper-col=\"wrapperCol\"\n  >\n    <button @click=\"addType\">添加类别</button>\n    <div\n      v-for=\"(item, index) in form.typeList\"\n      style=\"border: 1px solid; width: 60%; margin: 10px auto\"\n      :key=\"index\"\n    >\n      <a-form-model-item\n        label=\"类别\"\n        :prop=\"'typeList[' + index + ']' + '.type'\"\n        :rules=\"[\n          {\n            required: true,\n            trigger: 'change',\n            message: '请选择类别',\n          },\n          { validator: category },\n        ]\"\n      >\n        <a-select v-model=\"item.type\" placeholder=\"请选择类别\">\n          <a-select-option value=\"类别一\">类别一</a-select-option>\n          <a-select-option value=\"类别二\">类别二</a-select-option>\n        </a-select>\n      </a-form-model-item>\n      <div\n        v-for=\"(tab, indx) in item.tabs\"\n        style=\"border: 1px solid; width: 60%; margin: 10px auto\"\n        :key=\"indx\"\n      >\n        <a-form-model-item\n          label=\"姓名\"\n          :prop=\"'typeList[' + index + ']' + '.tabs[' + indx + ']'.name\"\n          :rules=\"[\n            {\n              required: true,\n              trigger: 'blur',\n              message: '请选择姓名',\n            },\n            { validator: category },\n          ]\"\n        >\n          <a-input v-model=\"tab.name\" />\n        </a-form-model-item>\n        <a-form-model-item\n          label=\"年龄\"\n          :prop=\"'typeList[' + index + ']' + '.tabs[' + indx + ']'.name\"\n          :rules=\"[\n            {\n              required: true,\n              trigger: 'change',\n              message: '请选择年龄',\n            },\n            { validator: category },\n          ]\"\n        >\n          <a-select v-model=\"tab.age\" placeholder=\"请选择年龄\">\n            <a-select-option value=\"年龄一\">年龄一</a-select-option>\n            <a-select-option value=\"年龄二\">年龄二</a-select-option>\n          </a-select>\n        </a-form-model-item>\n        <button @click=\"removeTab(tab, item.tabs)\">删除个人信息</button>\n      </div>\n      <button @click=\"addTab(item.tabs)\">添加个人信息</button>\n      <button @click=\"removeType(item)\">删除类别</button>\n    </div>\n    <a-form-model-item :wrapper-col=\"{ span: 14, offset: 4 }\">\n      <a-button type=\"primary\" @click=\"onSubmit\">提交表单</a-button>\n      <a-button type=\"primary\" @click=\"edit\">修改数据</a-button>\n    </a-form-model-item>\n  </a-form-model>\n</template>\n\n<script>\nexport default {\n  data() {\n    return {\n      labelCol: { span: 4 },\n      wrapperCol: { span: 14 },\n      form: {\n        typeList: [\n          {\n            type: \"\",\n            tabs: [\n              {\n                name: \"\",\n                age: \"\",\n              },\n            ],\n          },\n        ],\n      },\n    };\n  },\n  methods: {\n    onSubmit() {\n      this.$refs.refForm.validate((valid) => {\n        if (valid) {\n          alert(\"submit!\");\n        } else {\n          console.log(\"error submit!!\");\n          return false;\n        }\n      });\n    },\n    category(rule, value, callback) {\n      if (!value) {\n        callback(new Error(\"请选择\"));\n      } else {\n        callback();\n      }\n    },\n\n    edit() {\n      this.form.typeList = [\n        {\n          type: \"类别一\",\n          tabs: [\n            {\n              name: \"张三\",\n              age: \"年龄一\",\n            },\n            {\n              name: \"李四\",\n              age: \"年龄二\",\n            },\n          ],\n        },\n        {\n          type: \"类别二\",\n          tabs: [\n            {\n              name: \"王五\",\n              age: \"年龄一\",\n            },\n            {\n              name: \"三小\",\n              age: \"年龄二\",\n            },\n          ],\n        },\n      ];\n    },\n    addTab(tabs) {\n      tabs.push({\n        name: \"\",\n        age: \"\",\n      });\n    },\n    removeTab(tab, tabs) {\n      let index = tabs.indexOf(tab);\n      if (index !== -1) {\n        //当没有多余tab时就不再删除\n        tabs.splice(index, 1);\n      }\n    },\n    addType() {\n      this.form.typeList.push({\n        type: \"\",\n        tabs: [],\n      });\n    },\n    removeType(item) {\n      let index = this.form.typeList.indexOf(item);\n      if (index !== -1) {\n        //当没有多余tab时就不再删除\n        this.form.typeList.splice(index, 1);\n      }\n    },\n  },\n};\n</script>\n\n```\n\n\n\n","tags":["Vue-antDesign"]},{"title":"动态添加删除表单","url":"/2020/11/29/vue使用动态添加表单/","content":"\n#### 1.动态添加删除表单代码\n\n```\n<template>\n  <a-form-model :model=\"form\" :label-col=\"labelCol\" :wrapper-col=\"wrapperCol\">\n    <button @click=\"addType\">添加类别</button>\n    <div\n      v-for=\"item in form.typeList\"\n      style=\"border: 1px solid; width: 60%; margin: 10px auto\"\n      :key=\"item\"\n    >\n      <a-form-model-item label=\"类别\">\n        <a-select v-model=\"item.type\" placeholder=\"请选择类别\">\n          <a-select-option value=\"类别一\">类别一</a-select-option>\n          <a-select-option value=\"类别二\">类别二</a-select-option>\n        </a-select>\n      </a-form-model-item>\n      <div\n        v-for=\"(tab, index) in item.tabs\"\n        style=\"border: 1px solid; width: 60%; margin: 10px auto\"\n        :key=\"tab\"\n      >\n        <a-form-model-item label=\"姓名\">\n          <a-input v-model=\"tab.name\" />\n        </a-form-model-item>\n        <a-form-model-item label=\"年龄\">\n          <a-select v-model=\"tab.age\" placeholder=\"请选择年龄\">\n            <a-select-option value=\"年龄一\">年龄一</a-select-option>\n            <a-select-option value=\"年龄二\">年龄二</a-select-option>\n          </a-select>\n        </a-form-model-item>\n        <button @click=\"removeTab(tab, item.tabs)\">删除个人信息</button>\n      </div>\n      <button @click=\"addTab(item.tabs)\">添加个人信息</button>\n      <button @click=\"removeType(item)\">删除类别</button>\n    </div>\n    <a-form-model-item :wrapper-col=\"{ span: 14, offset: 4 }\">\n      <a-button type=\"primary\" @click=\"onSubmit\">提交表单</a-button>\n      <a-button type=\"primary\" @click=\"edit\">修改数据</a-button>\n    </a-form-model-item>\n  </a-form-model>\n</template>\n\n<script>\nexport default {\n  data() {\n    return {\n      labelCol: { span: 4 },\n      wrapperCol: { span: 14 },\n      form: {\n        typeList: [],\n      },\n    };\n  },\n  methods: {\n    onSubmit() {\n      console.log(\"submit!\", this.form);\n    },\n    edit() {\n      this.form.typeList = [\n        {\n          type: \"类别一\",\n          tabs: [\n            {\n              name: \"张三\",\n              age: \"年龄一\",\n            },\n            {\n              name: \"李四\",\n              age: \"年龄二\",\n            },\n          ],\n        },\n        {\n          type: \"类别二\",\n          tabs: [\n            {\n              name: \"王五\",\n              age: \"年龄一\",\n            },\n            {\n              name: \"三小\",\n              age: \"年龄二\",\n            },\n          ],\n        },\n      ];\n    },\n    addTab(tabs) {\n      tabs.push({\n        name: \"\",\n        age: \"\",\n      });\n    },\n    removeTab(tab, tabs) {\n      let index = tabs.indexOf(tab);\n      if (index !== -1) {\n        //当没有多余tab时就不再删除\n        tabs.splice(index, 1);\n      }\n    },\n    addType() {\n      this.form.typeList.push({\n        type: \"\",\n        tabs: [],\n      });\n    },\n    removeType(item) {\n      let index = this.form.typeList.indexOf(item);\n      if (index !== -1) {\n        //当没有多余tab时就不再删除\n        this.form.typeList.splice(index, 1);\n      }\n    },\n  },\n};\n</script>\n\n```\n\n\n\n","tags":["Vue-antDesign"]},{"title":"javaScript之动态创建dom元素","url":"/2020/07/31/javaScript之动态创建dom元素/","content":"\n### 解决思路\n\n#### 1.创建元素\n\n```\ndocument.createElement('span')\n```\n\n#### 2.找到父级元素\n\n```\ndocument.querySelector('.parent')\n```\n\n#### 3.在指定位置插入元素\n\n```\n // 在父级元素里最前面动态添加元素\n        parent.insertBefore(span, parent.childNodes[0]);\n // 在父级元素里最后面动态添加元素\n        parent.appendChild(span1)\n```\n\n### 完整代码\n\n```\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Document</title>\n</head>\n<body>\n    <div class=\"parent\">\n        <span>你好吗</span>\n    </div>\n</body>\n\n</html>\n<script>\n    window.onload = function () {\n        var span = document.createElement('span');\n        span.innerHTML = \"你好世界\"\n\n        var span1 = document.createElement('span');\n        span1.innerText = 'Hello,world'\n\n        var parent = document.querySelector('.parent');\n        // 在父级元素里最前面动态添加元素\n        parent.insertBefore(span, parent.childNodes[0]);\n        // 在父级元素里最后面动态添加元素\n        parent.appendChild(span1)\n    }\n</script>\n```\n\n","tags":["javaScript"]},{"title":"vue之项目打包成apk","url":"/2019/12/15/vue之项目打包成apk/","content":"\n#### 1.第一步（重要）\n\n登录阿里云在远程服务器添加一个4000端口 ***\n\n修改服务器上：C:\\Windows\\System32\\drivers\\etc中的hosts文件\n\n```\n172.24.42.8     localhost\n```\n\n注意：前者：服务器内网     后者：接口运行为：localhost:4000\n\n***在服务器端运行接口：node app(localhost:4000)与第三步对应***\n\n#### 2.第二步\n\n \t修改vue.config.js中的publicPath(解决资源找不到路径问题)\n\n```\n  publicPath: process.env.NODE_ENV === 'production'\n      ? './cli-study/dist'\n      : '/'\n```\n\n#### 3.第三步\n\n打包成app不存在跨域访问的问题\n\n```\n axios.defaults.baseURL = \"http://39.105.27.132:4000\"\n 注意：39.105.27.132是服务器的公网。\n      4000后端接口的端口号\n```\n\n#### 4.第四步\n\n执行 npm run build 打包 成dist\t\n\n#### 5.第五步\n\n打开hbuilder\n\n​    1.文件+新建+移动App（项目名）\n\n​    2.把项目中除了.project 和manifest.json的所有文件删除\n\n​    3.把dist中的文件拷贝到项目中\n\n####   6.第六步\n\n 配置manifest.json文件\n\n​     修改应用信息\n\n​     修改图标配置\n\n​      修改启动图片\n\n####   7.第七步\n\n​\t打包发行\n\n​    项目右键+发行\n\n####   8.第八步\n\n​\t拷贝apk ,安装\n\n\n\n","tags":["项目打包"]},{"title":"vue之代码配置","url":"/2019/11/29/vue之代码配置/","content":"\n#### 1.eslint\n\n```\nmodule.exports = {\n  root: true,\n  env: {\n      node: true\n  },\n  'extends': [\n      'plugin:vue/recommended',\n      'eslint:recommended'\n  ],\n  rules: {\n      // 关闭必须使用单引号\n      'quotes': [0, 'single'],\n      'no-console': process.env.NODE_ENV === 'production' ? 'error' : 'off',\n      'no-debugger': process.env.NODE_ENV === 'production' ? 'error' : 'off',\n      'prefer-promise-reject-errors': 0,\n      'space-unary-ops': 0,\n      'no-unused-expressions': 0,\n      'no-useless-return': 0,\n      'standard/no-callback-literal': 0,\n      'import/first': 0,\n      'import/export': 0,\n      'no-mixed-operators': 0,\n      'no-use-before-define': 0,\n\n      // 不允许使用分号\n      'semi': [2, 'never'],\n\n      // 允许使用==\n      'eqeqeq': 0,\n\n      // 缩进使用不做限制\n      'indent': 2,\n\n      // 允许使用tab\n      'no-tabs': 0,\n\n      // 函数圆括号之前没有空格\n      'space-before-function-paren': [2, 'never'],\n\n      // 不要求块内空格填充格式\n      'padded-blocks': 0,\n\n      // 不限制变量一起声明\n      'one-var': 0,\n\n      // 条件语句中复制操作符需要用圆括号括起来\n      'no-cond-assign': [2, 'except-parens'],\n\n      // 允许使用条件表达式使用常量\n      'no-constant-condition': 2,\n\n      // 单行可忽略大括号，多行不可忽略\n      'curly': [2, 'multi-line'],\n\n      // 不允许使用var变量\n      'no-var': 2,\n\n      'no-unused-vars':0,\n\n      // 不允许出现多个空格\n      'no-multi-spaces': ['error', { ignoreEOLComments: true }],\n      'camelcase': 0,\n\n      // 对象字面量的键值空格风格\n      'key-spacing': 2,\n\n      // if语句包含一个return语句， else就多余\n      'no-else-return': 2,\n\n      // 建议将经常出现的数字提取为变量\n      'no-magic-numbers': [0, { ignoreArrayIndexes: true }],\n\n      // 不允许重复声明变量\n      'no-redeclare': [2, { builtinGlobals: true }],\n\n      // 立即执行函数风格\n      'wrap-iife': [2, 'inside'],\n\n      // 不允许圆括号中出现空格\n      'space-in-parens': [2, 'never'],\n\n      // 确保运算符周围有空格\n      'space-infix-ops': 2,\n\n      // 强制点号与属性同一行\n      'dot-location': [2, 'property'],\n\n      // 强制单行代码使用空格\n      'block-spacing': [2, 'always'],\n\n      // 约束for-in使用hasOwnProperty判断\n      'guard-for-in': 0,\n\n      // 采用one true brace style大括号风格\n      'brace-style': [2, '1tbs', { 'allowSingleLine': true }],\n\n      // 统一逗号周围空格风格\n      'comma-spacing': [2, { 'before': false, 'after': true }],\n\n      // 禁止出现多个空行\n      'no-multiple-empty-lines': [2, { 'max': 1, 'maxEOF': 2 }],\n\n      // 允许箭头函数不使用圆括号\n      'arrow-parens': 0,\n\n      // 规范generator函数的使用\n      'generator-star-spacing': [2, { 'before': false, 'after': true }],\n\n      // 要求在块级\n      'lines-around-comment': [2, { 'beforeBlockComment': true, 'afterBlockComment': false, 'beforeLineComment': true, 'afterLineComment': false }]\n  },\n  parserOptions: {\n      parser: 'babel-eslint'\n  }\n}\n\n```\n\n#### 2.postcss.config.js\n\n```\nmodule.exports = {\n  plugins: {\n    //autoprefixer 自动补全css前缀的东西\n    'autoprefixer': {\n      //兼容的机型\n      browsers: ['Android >= 4.0', 'iOS >= 7']\n    },\n    'postcss-pxtorem': {\n      rootValue: 37.5, //换算基数，一般和html的font-size一致\n      propList: ['*']  //哪些css属性需要换算\n    }\n  }\n};\n```\n\n#### 3.vue.config.js\n\n```\nconst path = require('path'),\n\n    //debug是判断当前是开发环境还是发布环境\n    debug = process.env.NODE_ENV !== 'production'\n\nmodule.exports = {\n\n    //部署应用包时的基本URL，如果是生产环境，部署到 /cli-study/dist 路径；如果是开发环境，部署到根路径\n    publicPath: process.env.NODE_ENV === 'production'\n        ? './'\n        : './',\n\n    //输出文件路径\n    outputDir: 'dist',\n\n    //放置生成的静态资源 (js、css、img、fonts) 的 (相对于 outputDir 的) 目录。\n    assetsDir: 'static',\n\n    //默认情况下，生成的静态资源在它们的文件名中包含了 hash 以便更好的控制缓存\n    filenameHashing: true,\n\n    // 是否使用包含运行时编译器的Vue构建版本，设置为 true 后你就可以在 Vue 组件中使用 template 选项了，但是这会让你的应用额外增加 10kb 左右。\n    runtimeCompiler: true,\n\n    // 默认情况下 babel-loader 会忽略所有 node_modules 中的文件。如果你想要通过 Babel 显式转译一个依赖，可以在这个选项中列出来。\n    transpileDependencies: [],\n\n    // 发布环境不需要sourceMap\n    productionSourceMap: false,\n\n    css: {\n\n        // 默认情况下，只有 *.module.[ext] 结尾的文件才会被视作 CSS Modules 模块。设置为 true 后你就可以去掉文件名中的 .module 并将所有的 *.(css|scss|sass|less|styl(us)?) 文件视为 CSS Modules 模块。\n        modules: false,\n\n        // 是否将组件中的 CSS 提取至一个独立的 CSS 文件中 (而不是动态注入到 JavaScript 中的 inline 代码)。\n        extract: true,\n\n        // 是否构建样式地图，false 将提高构建速度\n        sourceMap: true,\n\n        // css预设器配置项\n        loaderOptions: {\n            css: {\n\n                //这里的选项会传递给 css-loader\n            },\n            postcss: {\n\n                // 这里的选项会传递给 postcss-loader\n            }\n        },\n    },\n\n    //所有 webpack-dev-server 的选项都支持\n    devServer: {\n        open: true,\n        host: '127.0.0.1',\n        port: 3000,\n        https: false,\n        hotOnly: false,\n        proxy: {\n          //凡是请求以api开头的都会使用下面的代理服务器\n          '/api/*': {\n            target: 'http://localhost:8899/', // 目标服务器地址\n            secure: false,                    // 目标服务器地址是否是安全协议\n            changeOrigin: true,               // 是否修改来源, 为true时会让目标服务器以为是webpack-dev-server发出的请求!服务端和服务端的请求是没有跨域的\n            //pathRewrite: {'^/api': '/a'}     // 将/api开头的请求地址, /api 改为 /, 即 /api/xx 改为 /xx\n          }\n        }\n    },\n\n    // 第三方插件配置\n    pluginOptions: {},\n\n    //调整webpack配置的最简单的方式\n    configureWebpack: config => {\n        if (!debug) {\n\n            // 为生产环境修改配置...\n            config.devtool = '#cheap-module-source-map'\n        } else {\n\n            // 为开发环境修改配置...\n            config.devtool = '#cheap-module-eval-source-map'\n        }\n\n        Object.assign(config, { // 开发生产共同配置\n            resolve: {\n                alias: {\n                    '@': path.resolve(__dirname, './src'),\n                    'vue$': 'vue/dist/vue.js'\n                }\n            }\n        })\n    },\n\n    //webpack的链式编程\n    chainWebpack: () => {\n        if (debug) {\n\n            // 本地开发配置\n        } else {\n\n            // 生产开发配置\n        }\n    },\n\n    /*  pages: {\n    index: {\n      // page 的入口\n      entry: 'src/index/main.js',\n      // 模板来源\n      template: 'public/index.html',\n      // 在 dist/index.html 的输出\n      filename: 'index.html',\n      // 当使用 title 选项时，\n      // template 中的 title 标签需要是 <title><%= htmlWebpackPlugin.options.title %></title>\n      title: 'Index Page',\n      // 在这个页面中包含的块，默认情况下会包含\n      // 提取出来的通用 chunk 和 vendor chunk。\n      //chunk参考：https://segmentfault.com/q/1010000016925412/a-1020000016946034\n      chunks: ['chunk-vendors', 'chunk-common', 'index']\n    }\n  },*/\n\n    lintOnSave: false,\n}\n\n```\n\n#### 4.代码关联\n\n```\n1.打开git brash，输入命令:ssh-keygen -t rsa -C \"1078838865l@qq.com\"\n2.配置本地全局的账号和密码\n  git config --global user.name \"QiangGe-super\"\n  git config --global user.email \"1078838865l@qq.com\"\n3.关联远程仓库\ngit remote add origin https://github.com/QiangGe-super/vue_shop.git\ngit push -u origin master\n\n\n4.在main.js引入mui:\nimport 'mui/css/mui.css'\nimport 'mui/css/icons-extra.css'\n\n5.在main.js中引入mint-ui\nimport MintUI from 'mint-ui'\nimport 'mint-ui/lib/style.css'\nVue.use(MintUI)\n\n```\n\n","tags":["配置"]},{"title":"vue之跨域问题及其解决方案","url":"/2019/11/27/vue之跨域问题及其解决方案/","content":"\n### 1.跨域\n\n跨域问题：只有在前端的ajax和后台交互的过程中才会存在\n\n当我们使用ajax从一个url向另外一个url发送请求的时候，只要两个url的协议、域名、端口号有任何一个不一样，就构成跨域\n\n#### 1.1\tJSONP\n\n1.1.1 JSONP介绍\nJSONP：是使用script标签向服务器发送请求的一种方式，然后在服务器中客户端返回了一段js脚本，客户端接收到这个js脚本之后就会执行该脚本了。\n\n在使用JSONP来解决跨域请求问题的时候，需要服务端的配合。\nJSONP只能够发送GET请求。\nJSONP和AJAX有关系吗? 没有任何关系\n\n//通过script标签是可以发送请求\n\n```\n  var script = document.createElement('script')\n    script.src = 'http://localhost:8888/test'\n    document.body.appendChild(script)\n```\n\n    //获取script标签请求的结果:在服务器返回一段js脚本，客户端接收到js脚本之后会立刻执行该脚本\n    function test(msg){\n        console.log(msg)\n    }\n\n```\napp.get(\"/test\",(req,res)=>{\n    res.header(\"content-type\",\"application/javascript\")\n    var person = {\n        name:\"kk\",\n        age:\"19\"\n    }\n    res.send(`test(${JSON.stringify(person)})`)\n})\n```\n\n1.1.2 ajax中jsonp的使用\n\n```\najax的dataType可以指定怎么处理服务器响应给客户端的数据\n\ntext/xml  ： 对服务器的相应结果不做任何处理\nhtml  ： 服务器给客户端响应了一个页面代码，页面代码中script会在代码拼接到dom执行\njson : 会调用JSON.parse()来解析服务器的响应结果\nscript : 服务器给客户端响应了js脚本，客户端接收到js脚本之后立马执行\njsonp ：客户端给服务器发送jsonp请求，服务器返回了一段js脚本\n\n$.ajax({\n        type:\"get\",\n        url:\"http://localhost:8888/test2\",\n        dataType:\"jsonp\",\n        //指定回调函数的key\n        // jsonp:\"callback\",\n        //指定回调函数的名字\n        // jsonpCallback:\"kk\",\n        success:function(msg){\n            console.log(msg);\n        }\n    })\n\n\napp.get(\"/test2\",(req,res)=>{\n    //声明服务器发送给客户端的数据类型是javascript脚本\n    res.header(\"content-type\",\"application/javascript\")\n    //获取到客户端传递给服务器的回调函数的名字\n    var functionName = req.query.callback;\n    //服务器传递给客户端的数据\n    var person = {\n        name:\"ppp\",\n        age:\"19\"\n    }\n    //给客户端发送一段js脚本\n    res.send(`typeof(${functionName}) == 'function' && ${functionName}(${JSON.stringify(person)})`)\n})\n```\n\n#### 1.2\tCORS\n\n```\nCross Origin Resource Share，跨域资源共享。不需要客户端做额外的处理，只要服务添加下面代码即可。\n//服务端代码 \napp.all('*', function(req, res, next) {\n    res.header(\"Access-Control-Allow-Origin\", \"*\");\n    res.header('Access-Control-Allow-Headers', 'Content-type');\n    res.header(\"Access-Control-Allow-Methods\", \"PUT,POST,GET,DELETE,OPTIONS,PATCH\");\n    res.header('Access-Control-Max-Age',6000);//预请求缓存10分钟\n    next();  \n});\n```\n\n#### 1.3.配置devserver的proxy\n\n在前端的工程化项目(webpack)中,我们可以通过配置devserver的proxy来解决跨域访问的问题。他的原理是在本地开启一个服务器向数据服务器发送请求，因为服务器和服务器之间是没有跨域\n\n#### 1.4.反向代理（ngix）\n\n但是因为webpack的devserver只在开发环境下有效，当项目发布上线之后仍然会有跨域问题，为了解决项目上线的跨域问题，我们配置服务器的反向代理（ngix）\n\n#### 1.5.打包成apk\n\n除此之外，我还知道当项目打包成apk之后就不存在跨域问题了，所以如果项目要打包成apk，我们需要在项目中的所有请求中写全路径(此时我们可以配置axios.default.baseURL来解决)","tags":["上线"]},{"title":"vue之使用Apache服务器对项目进行上线","url":"/2019/11/15/vue之使用Apache服务器进行项目上线/","content":"\n#### 1.第一步\n\n项目npm run build 生成dist目录\n\n注意：把mui 中的所有svg注释掉\n\n#### 2.第二步\n\n解压Apache\n\n![img](/img/01/Apache.png) \n\n在Apache的bin目录下执行：httpd -t 查看是否出错\n\n#### 3.第三步（以下均在服务端操作）\n\n修改Apache下的conf下的httpd.conf配置文件\n\n37行 Define SRVROOT \"E:/Apache\"\n\n39行 ServerRoot \"E:/Apache\"\n\n59行 \\#Listen 12.34.56.78:80\n\n60行  Listen 8010\n\n61行   Listen 8020\n\n142行  LoadModule proxy_module modules/mod_proxy.so\n\n151行  LoadModule proxy_http_module modules/mod_proxy_http.so\n\n 225行 ServerName localhost:8888\n\n 233行 Options Indexes FollowSymLinks\n\n  234行 AllowOverride None\n\n  235行 Order allow,deny\n\n  236行 Allow from all\n\n  251行  DocumentRoot \"C:\\\\\"\n\n  252行  <Directory \"C:\\\\\">\n\n#### 4.第四步\n\n​\t把dist中的文件拷贝到E:/webapp中\n\n#### 5.第五步\n\n​    在Apache的bin目录下执行：\n\n​     安装：$ httpd.exe -k install -n \"Apache\"\n\n​\t  卸载：$ httpd.exe -k uninstall -n \"Apache\"\n\n​      Win+R: services.msc启动或停止Apache服务器。\n\n####   6.第六步\n\n​       在浏览器中输入localhost:8010查看网页显示\n\n####   7.第七步\n\n​\t\t配置Apache虚拟目录（允许Apache运行多个项目）\n\n​        509行： \\# Virtual hosts\n\n​         510行：Include conf/extra/httpd-vhosts.conf（打开）\n\n####   8.第八步(配置反向代理)\n\n```\n  <VirtualHost *:8010> \n\n  DocumentRoot \"E:/webapp\"\n\n  <Directory \"E:/webapp\">\n\n​    Options FollowSymLinks Indexes \n\n​    AllowOverride none\n\n​    Require all granted\n\n  </Directory>\n\n  Proxyrequests off\n\n  <Proxy *>\n\n​    \\#规定Deny,Allow的执行顺序, Order Deny,Allow ： 先执行Deny，再执行Allow\n\n​    Order Deny,Allow\n\n​    \\#全部禁止访问 取值：all none 指定ip\n\n​    Allow from All\n</Proxy>\n        #配置反向代理\n\t\tProxyPass /cellphone http://172.24.42.8:4000/cellphone\n\t\tProxyPass /banner http://172.24.42.8:4000/banner\n\t\tProxyPass /user http://172.24.42.8:4000/user\n\t\tProxyPass /like http://172.24.42.8:4000/like\n\t\tProxyPass /likelist http://172.24.42.8:4000/likelist\n\t\tProxyPass /search http://172.24.42.8:4000/search\n\t\tProxyPass /personalized http://172.24.42.8:4000/personalized\n\t\tProxyPass /playlist http://172.24.42.8:4000/playlist\n\t\tProxyPass /lyric http://172.24.42.8:4000/lyric\n\t\tProxyPass /top http://172.24.42.8:4000/top\n\t\tProxyPass /toplist http://172.24.42.8:4000/toplist\n\t\tProxyPass /comment http://172.24.42.8:4000/comment\n\t\tProxyPass /artist http://172.24.42.8:4000/artist\n\t\tProxyPass /artists http://172.24.42.8:4000/artists\n\t\tProxyPass /song http://172.24.42.8:4000/song\n\n</VirtualHost>\n\n<VirtualHost *:8020> \n\n  DocumentRoot \"E:/webapp1\"\n\n  <Directory \"E:/webapp1\">\n\n​    Options FollowSymLinks Indexes \n\n​    AllowOverride none\n\n​    Require all granted\n\n  </Directory>\n\n  Proxyrequests off\n\n  <Proxy *>\n\n​    \\#规定Deny,Allow的执行顺序, Order Deny,Allow ： 先执行Deny，再执行Allow\n\n​    Order Deny,Allow\n\n​    \\#全部禁止访问 取值：all none 指定ip\n\n​    Allow from All\n\n  </Proxy>\n\n​    \\#配置反向代理\n\n  ProxyPass /cats http://api.zhuishushenqi.com/cats\n\n  ProxyPass /book http://api.zhuishushenqi.com/book\n\n  ProxyPass /post http://api.zhuishushenqi.com/post\n\n  ProxyPass /ranking http://api.zhuishushenqi.com/ranking\n\n  ProxyPass /btoc http://api.zhuishushenqi.com/btoc\n\n  ProxyPass /atoc http://api.zhuishushenqi.com/atoc\n\n  ProxyPass /chapter http://chapter2.zhuishushenqi.com/chapter \n</VirtualHost>\n```\n\n注意：\n\n在C:\\Windows\\System32\\drivers\\etc的hosts中添加\n\n​        172.24.42.8(服务器ip)     smallan.top（域名）\n\n####  9.访问\n\n​\t  smllant.top:8010   smllant.top:8020\n\n####  10.解决首屏加载比较慢的问题\n\n1.打开 httpd.conf配置文件中下面两个模块的注释\n\n```\n#LoadModule deflate_module modules/mod_deflate.so\n\n#LoadModule headers_module modules/mod_headers.so\n```\n\n2.在httpd.conf配置文件最下面添加\n\n```\n<IfModule deflate_module>\n\n  SetOutputFilter DEFLATE\n\n  DeflateCompressionLevel 9\n\n</IfModule>\n```\n\n","tags":["上线"]},{"title":"vue之如何进行移动端适配","url":"/2019/11/10/vue之如何进行移动端适配/","content":"\n#### 1.在css样式兼容性方面，我们可以使用autoprefixer插件\n\n```\npostcss可以被理解为一个平台，可以让一些插件在上面跑。它提供了一个解析器，可以将CSS解析成抽象语法树。通过PostCSS这个平台，我们能够开发一些插件，来处理CSS。热门插件如autoprefixer。\n\nvue-cli已经自动集成了postcss，所以我们可以在postcss.config.js这个配置文件中直接添加autoprefixer这个插件\n```\n\n#### 2.在屏幕大小适配方面，我们可以使用下面两种方案\n\n##### （1）使用flexible和 postcss-px2rem\n\n\t之前使用rem适配的思路：使用媒体查询，确定不同屏幕下html标签的font-size  (即1rem单位)，然后在写css样式的时候，就可以使用1rem , 2rem这样的单位来做适配了。\n\t\n\t但是这种适配的问题是需要手动把px单位换算成rem单位，比较麻烦。对应的，我们可以使用flexible和 postcss-px2rem来解决这个问题\n\n```javascript\n//1.安装flexible。 flexible主要是实现在各种不同的移动端界面实现一稿搞定所有的设备兼容自适应问题\nnpm install lib-flexible --save\n\n//2.main.js引入flexible\nimport 'lib-flexible'\n\n//此时运行程序会看到html中自动加上了font-size    font-size的默认值为viewport的十分之一\n//在页面中引入flexible.js后，flexible会在<html>标签上增加一个data-dpr属性和font-size样式（如下图）。\n\n//3.安装postcss-pxtorem\nnpm install postcss-pxtorem --save-dev\n\n//4.修改postcss.config.js\nmodule.exports = {\n  plugins: {\n    //autoprefixer 自动补全css前缀的东西\n    'autoprefixer': {\n      //兼容的机型\n      browsers: ['Android >= 4.0', 'iOS >= 7']\n    },\n    'postcss-pxtorem': {\n      rootValue: 37.5, //换算基数，一般和html的font-size一致\n      propList: ['*']  //哪些css属性需要换算\n    }\n  }\n};\n```\n\n##### （2） 使用postcss-px-to-viewport\n\n\t`vw` 与 `vh`单位，以`viewport`为基准，`1vw` 与 `1vh`分别为`window.innerWidth` 与 `window.innerHeight`的百分之一。\n\t\n\tvw/vh 单位其实出现比较早了，只是以前支持性不太好，现在随着浏览器的发展，大部分（92%以上）的浏览器已经支持了vw/vh\n\n```javascript\nnpm i postcss-px-to-viewport -save -dev\n\n//修改postcss.config.js\nmodule.exports = {\n  plugins: {\n      autoprefixer: {\n          //兼容的机型\n      \t  browsers: ['Android >= 4.0', 'iOS >= 7']\n      },\n    //px转换为vw单位的插件\n    \"postcss-px-to-viewport\": {\n      //1vw = 3.2\n      viewportWidth: 320,\n      //1vh = 5.68\n      viewportHeight: 568,\n      // px to vw无法整除时，保留几位小数\n      unitPrecision: 5,\n      // 转换成vw单位   \n      viewportUnit: 'vw',\n     //不转换的类名\n      selectorBlackList: [],\n      // 小于1px不转换\n      minPixelValue: 1,\n     //允许媒体查询中转换\n      mediaQuery: false,\n      //排除node_modules文件中第三方css文件\n      exclude: /(\\/|\\\\)(node_modules)(\\/|\\\\)/  \n    },\n  }\n};\n```\n\n#### ","tags":["移动端适配"]},{"title":"vue之生命周期及父子组件生命周期的执行顺序","url":"/2019/09/24/vue之生命周期的介绍及父子组件的生命周期执行顺序/","content":"\n### vue的生命周期\n\n####     1.beforeCreate和created\n\n    //组件创建之前 ： 在该方法中因为组件还没有创建完毕，所以无法获取组件中的methods和data中的数据\n         beforeCreate:function(){\n             console.log(\"beforeCreate\",this.msg,this.add)\n        // 直接通过dom操作获取最原始在页面信息\n         // console.log(document.getElementById(\"box\"))\n    \n         // this.$refs 要等到内存中的虚拟dom挂载到真实dom才能使用\n         // console.log(this.$refs.box,\"xxx\")  undefined\n    \n     },\n     //组件实例已经创建完毕 ：在该方法中可以获取到组件的methods和data中的数据\n     created:function(){\n         console.log(\"created\",this.msg,this.add)\n    \n    console.log(this.$el,\"created\")\n\n#### \t2.Mount和Mounted\n\n```\n //在内存中编译页面模板(虚拟dom   this.$el),但是内存的模板还没有被渲染到真实dom\n //在beforeMount执行的时候，页面中的元素还没有被真正替换过来，只是之前写的一些模板字符串\n //在beforeMount方法里面我们获取不到真正的页面\n beforeMount:function(){\n     console.log(this.$el,\"beforeMount\")\n     console.log(document.getElementById(\"box\").innerText,\"beforeMount\") //{{msg}}\n },\n //内存中的页面模板被渲染dom之后执行\n //在mounted执行的时候，内存中虚拟dom已经被真正替换了，而且也已经渲染到真实dom\n //在mounted方法里面我们可以获取到真正的页面了\n mounted:function(){\n     console.log(this.$el,\"mounted\")\n     //下面打印能够看到实际的内容，原因是内存中的虚拟dom已经被挂载到真实dom了\n     console.log(this.$refs.box,\"xxx\")\n },\n```\n#### 3.beforeUpdate和updated\n\n```\n//当数据源变了，在更新页面之前会先执行beforeUpdate，此时页面还没有更新\n beforeUpdate:function(){\n     console.log(\"beforeUpdate\",this.$refs.box.innerText)\n },\n //当数据源变了，在更新页面之后会先执行updated，此时页面已经是最新了\n updated:function(){\n     console.log(\"updated\",this.$refs.box.innerText)\n },\n```\n\n#### 4.beforeDestory和Destoryed\n\n```\n//当vue实例销毁之前执行，我们可以在这个函数里面做一些资源释放工作 \n //比如关闭定时器\n beforeDestroy:function(){\n     console.log(\"beforeDestroy方法执行了\")\n },\n //vue实例已经销毁完毕\n destroyed:function(){\n     console.log(\"destroyed方法执行了\")\n }\n```\n\n### 组件嵌套子组件的生命周期执行顺序\n\n先执行父级的beforeCreate、created 和 beforeMount，\n\n然后再去执行子组件的beforeCreate、created 和 beforeMount，\n\n如果子组件下面没有子组件了，就执行 mounted，然后再返回父级执行 mounted。","tags":["vue"]},{"title":"vue之路由在keep-alive下的刷新问题","url":"/2019/09/24/vue之路由在keep-alive下的刷新问题/","content":"\n#### 1.keep-alive的介绍\n\n​\t\tkeep-alive是Vue的内置组件，能在组件切换过程中将状态保留在内存中，防止重复渲染DOM。\n\nkeep-alive包裹动态组件时，会缓存不活动的组件实例，而不是销毁它们。和 transition>相似，keep-alive是一个抽象组件：它自身不会渲染一个 DOM 元素，也不会出现在父组件链中\n\n#### 2.两个参数（prop)\n\n```\ninclude: 字符串或正则表达式。只有匹配的组件会被缓存。\nexclude: 字符串或正则表达式。任何匹配的组件都不会被缓存\n```\n\n#### 3.常见用法\n\n```\n// 在组件中使用\nexport default {\n  name: 'music',\n  data () {\n    return {\n    \t//excludeComponents:'music',\n        includedComponents: 'music'\n    }\n  }\n}\n```\n\n```\n<keep-alive include=\"music\">\n  <!-- 将缓存name为music的组件 -->\n  <component></component>\n</keep-alive>\n\n<keep-alive include=\"a,b\">\n  <!-- 将缓存name为a或者b的组件，结合动态组件使用 -->\n  <component :is=\"view\"></component>\n</keep-alive>\n\n<!-- 使用正则表达式，需使用v-bind -->\n<keep-alive :include=\"/a|b/\">\n  <component :is=\"view\"></component>\n</keep-alive>\n\n<!-- 动态判断 -->\n<keep-alive :include=\"includedComponents\">\n  <router-view></router-view>\n</keep-alive>\n\n<keep-alive exclude=\"test-keep-alive\">\n  <!-- 将不缓存name为test-keep-alive的组件 -->\n  <component></component>\n</keep-alive>\n```\n\n#### 4.结合router，缓存部分页面\n\n```\n使用$route.meta的keepAlive属性：\n<keep-alive>\n    <router-view v-if=\"$route.meta.keepAlive\"></router-view>\n</keep-alive>\n<router-view v-if=\"!$route.meta.keepAlive\"></router-view>\n\n```\n\n```\n需要在router中设置router的元信息meta：\n//...router.js\nexport default new Router({\n  routes: [\n    {\n      path: '/',\n      name: 'Hello',\n      component: Hello,\n      meta: {\n        keepAlive: false // 不需要缓存\n      }\n    },\n    {\n      path: '/page1',\n      name: 'Page1',\n      component: Page1,\n      meta: {\n        keepAlive: true // 需要被缓存\n      }\n    }\n  ]\n})\n```\n\n#### 5.route.meta中keepAlive属性实现其他需求\n\n    首页是A页面\n    B页面跳转到A，A页面需要缓存\n    C页面跳转到A，A页面不需要被缓存\n    \n    思路:在每个路由的beforeRouteLeave(to, from, next)钩子中设置to.meta.keepAlive\n    \n    keep-alive生命周期钩子函数：activated、deactivated\n    使用<keep-alive>会将数据保留在内存中，如果要在每次进入页面的时候获取最新的数据，需要在activated阶段获取数据，承担原来created钩子中获取数据的任务。\n\nA的路由：\n\n```\n{\n    path: '/',\n    name: 'A',\n    component: A,\n    meta: {\n        keepAlive: true // 需要被缓存\n    }\n}\nexport default {\n    data() {\n        return {};\n    },\n    methods: {},\n    beforeRouteLeave(to, from, next) {\n         // 设置下一个路由的 meta\n        to.meta.keepAlive = true;  // B 跳转到 A 时，让 A 缓存，即不刷新\n        next();\n    }\n};\nexport default {\n    data() {\n        return {};\n    },\n    methods: {},\n    beforeRouteLeave(to, from, next) {\n        // 设置下一个路由的 meta\n        to.meta.keepAlive = false; // C 跳转到 A 时让 A 不缓存，即刷新\n        next();\n    }\n};\n```","tags":["vue"]},{"title":"vue之使用Vant组件实现下拉刷新和上拉加载","url":"/2019/09/22/vue之使用Vant组件实现下拉刷新和上拉加载/","content":"\n#### 1.Vant的介绍\n\n​\t\tVant 是有赞开源的一套基于 Vue 2.0 的 Mobile 组件库。通过 Vant，可以快速搭建出风格统一的页面，提升开发效率。目前已有近 50 个组件，这些组件被广泛使用于有赞的各个移动端业务中。 Vant 旨在更快、更简单地开发基于 Vue 的美观易用的移动站点\n\n#### 2.下拉刷新和上拉加载的实现\n\n（1）通过 npm 安装\n\n```\nnpm i vant -S\n```\n\n#### 3.在babel.config.js中配置\n\n```\n安装插件：\nnpm i babel-plugin-import -D\n```\n\n```\n添加配置：\n在 babel.config.js 中配置\nmodule.exports = {\n  plugins: [\n    ['import', {\n      libraryName: 'vant',\n      libraryDirectory: 'es',\n      style: true\n    }, 'vant']\n  ]\n};\n```\n\n#### 4.在main.js中引入样式表\n\n```\nimport 'vant/lib/index.css'\n```\n\n#### 5.在组件简单使用\n\n```\n<template>\n  <div class=\"contain\">\n    <van-pull-refresh v-model=\"isLoading\" @refresh=\"onRefresh\">\n      <van-list v-model=\"loading\" :finished=\"finished\" finished-text=\"没有更多了\" @load=\"onLoad\">\n        <van-cell v-for=\"item in list\" :key=\"item\" :title=\"item\" />\n      </van-list>\n    </van-pull-refresh>\n  </div>\n</template>\n```\n\n```\n<script>\nimport Vue from \"vue\";\nimport { List, Cell, PullRefresh } from \"vant\";\nimport { Toast } from \"vant\";\nVue.use(List);\nVue.use(Cell);\nVue.use(PullRefresh);\n\nexport default {\n  data: function() {\n    return {\n      list: [],\n      loading: false,\n      finished: false,\n      isLoading: false\n    };\n  },\n  methods: {\n    //返回\n    returnbtn() {\n      this.$router.go(-1);\n    },\n    // 上拉加载\n    onLoad() {\n      // 异步更新数据\n      // setTimeout 仅做示例，真实场景中一般为 ajax 请求\n      setTimeout(() => {\n        for (let i = 0; i < 20; i++) {\n          this.list.push(this.list.length + 1);\n        }\n        // 加载状态结束\n        this.loading = false;\n        // 数据全部加载完成\n        if (this.list.length >= 140) {\n          this.finished = true;\n        }\n      }, 1000);\n    },\n    // 下拉刷新\n    onRefresh() {\n      setTimeout(() => {\n        Toast(\"刷新成功\");\n        this.isLoading = false;\n        this.list = [];\n        this.finished = false;\n        for (let i = 0; i < 20; i++) {\n          this.list.push(this.list.length + 1);\n        }\n      }, 1000);\n    }\n  }\n};\n</script>\n```\n\n#### 6.在实际项目中的使用\n\n    <template>\n      <div class=\"contain\">\n        <div class=\"backimg\">\n          <i class=\"iconfont icon-zuojiantou\" @click=\"returnbtn()\" />\n          <div class=\"backimg-wenzi\">评论</div>\n        </div>\n        <van-pull-refresh v-model=\"isLoading\" @refresh=\"onRefresh\">\n          <van-list v-model=\"loading\" :finished=\"finished\" finished-text=\"没有更多了\" @load=\"onLoad\">\n            <div class=\"hotcomments\">\n              <h4>最新评论------{{total}}</h4>\n              <div class=\"hotcom\" v-for=\"(item,index) in commentsLists\" :key=\"index\">\n                <div class=\"hotcomimg\">\n                  <img v-lazy=\"item.user.avatarUrl\" alt />\n                  <div class=\"nickname\">\n                    {{item.user.nickname}}\n                    <br />\n                    {{item.time | dateFormat('HH:mm')}}\n                  </div>\n                  <div class=\"lickedcount\">\n                    {{item.likedCount}}\n                    <i class=\"iconfont icon-dianzan\" />\n                  </div>\n                </div>\n                <div class=\"content\">{{item.content}}</div>\n              </div>\n            </div>\n          </van-list>\n        </van-pull-refresh>\n      </div>\n    </template>\n    \n    <script>\n    import Vue from \"vue\";\n    import { List, Cell, PullRefresh } from \"vant\";\n    import { Toast } from \"vant\";\n    Vue.use(List);\n    Vue.use(Cell);\n    Vue.use(PullRefresh);\n    \n    import myaxios, {\n      getCommentList,\n      postComment,\n      isPassword\n    } from \"@/tools/myaxios.js\";\n    import { mapGetters } from \"vuex\";\n    \n    export default {\n      data: function() {\n        return {\n          list: [],\n          loading: false,\n          finished: false,\n          isLoading: false,\n    \n          hotCommentsLists: [],\n          commentsLists: [],\n          total: 0, //总共的数据条数\n          text: \"\",\n          page: 1, //请求第几页\n          pageSize: 10, //每页请求的数量\n          total: 0 //总共的数据条数\n        };\n      },\n      async created() {\n        //创建组件时，加载第1页数据\n        this.getList();\n      },\n      methods: {\n        //返回\n        returnbtn() {\n          this.$router.go(-1);\n        },\n        // 上拉加载\n        onLoad() {\n          setTimeout(() => {\n            this.page++;\n            this.getList();\n          }, 1000);\n        },\n        // 下拉刷新\n        onRefresh() {\n          setTimeout(() => {\n            Toast(\"刷新成功\");\n            this.isLoading = false;\n            this.commentsLists = [];\n            this.finished = false;\n            for (let i = 0; i < 20; i++) {\n              this.list.push(this.commentsLists.length + 1);\n            }\n          }, 1000);\n        },\n        async getList() {\n          console.log(this.$route.query.id)\n          let { data } = await myaxios(\n            \"GET\",\n            getCommentList + this.$route.query.id,\n            {\n              offset: this.page,\n              limit: this.pageSize\n            }\n          );\n          this.total = data.total;\n          this.loading = false;\n          // 返回当前页面的列表\n          let rows = data.comments;\n          if (rows == null || rows.length === 0) {\n            // 加载结束\n            this.finished = true;\n            return;\n          }\n          // 将新数据与老数据进行合并\n          this.commentsLists = this.commentsLists.concat(rows);\n          //如果列表数据条数>=总条数，不再触发滚动加载\n          if (this.commentsLists.length >= this.total) {\n            this.finished = true;\n          }\n        }\n      }\n    };\n    </script>\n    \n    <style lang=\"less\" scoped>\n    .contain {\n      //  返回\n      .backimg {\n        height: 40px;\n        line-height: 40px;\n        color: #fff;\n        .backimg-wenzi {\n          color: #fff;\n          height: 40px;\n          line-height: 40px;\n        }\n        .icon-zuojiantou {\n          font-size: 24px;\n          float: left;\n        }\n      }\n      // 评论内容\n      .hotcomments {\n        h4 {\n          color: #fff;\n        }\n        .hotcom {\n          margin: 20px;\n          color: #fff;\n          .content {\n            width: 260px;\n            margin: 0 auto;\n            //   height: 30px;\n          }\n          .hotcomimg {\n            height: 40px;\n            // border: 1px solid;\n            img {\n              float: left;\n              width: 40px;\n              height: 40px;\n              border-radius: 50%;\n            }\n            .nickname {\n              float: left;\n              margin-left: 10px;\n            }\n            .lickedcount {\n              float: right;\n            }\n          }\n        }\n      }\n    }\n    \n    .postcomment {\n      z-index: 1000;\n      position: fixed;\n      width: 100%;\n      bottom: 0px;\n      height: 50px;\n      background-color: #fff;\n    }\n    // 图片懒加载\n    img[lazy=\"loading\"] {\n      background: url(\"../../assets/images/smallant.jpg\");\n      background-size: 40px;\n    }\n    </style>\n","tags":["vue"]},{"title":"vue之moment和vuex之persistedstate","url":"/2019/09/20/vue之moment和vuex之persistedstate/","content":"\n### moment作用：时间格式化\n\n#### 1.安装\n\n```\nnpm install moment --save\n```\n\n#### 2.Main.js引入\n\n```\nimport moment from 'moment'\n\n// 定义全局的过滤器\n\nVue.filter('dateFormat', function (dataStr, pattern = \"YYYY-MM-DD HH:mm:ss\") {\n\n return moment(dataStr).format(pattern)\n\n})\n```\n\n#### 3.组件中按需使用\n\n```\nitem.time | dateFormat('mm:ss')\n```\n\n\n\n### vuex-persistedstate：解决刷新数据消失的问题\n\n####  1. 安装\n\n```\nnpm install vuex-persistedstate --savepersisitedstatepp\n```\n\n\n\n#### 2. 引入及配置\n\n```\nimport createPersistedState from \"vuex-persistedstate\"\n\nconst store = new Vuex.Store({\n\n // ...\n\n plugins: [createPersistedState()]\n\n})\n```\n\n","tags":["vue"]},{"title":"vuex之四个辅助函数的使用","url":"/2019/09/18/vuex之四个辅助函数的使用/","content":"\n#### 1.在Store (Index.js)中定义state,mutations,actions和getters\n\n```\nimport Vue from 'vue'\nimport Vuex from 'vuex'\nimport createPersistedstate from 'vuex-persistedstate'\n\nVue.use(Vuex)\nexport default new Vuex.Store({\n  state: {\n    playList: [],\n  \n  },\n  mutations: {    \n    setPlayList(state, list) {\n      state.playList = list\n    },\n  },\n  actions: {\n    selectPlay({commit, state}, {list, index}){\n      commit('setSequenceList', list)\n      commit('setPlayList', list)\n      commit('setCurrentIndex',index)\n      commit('setPlayState', true)\n    }\n  },\n  getters: {\n    playList: function (state) {\n      return state.playList\n    },\n   \n})\n```\n\n#### 2.页面引入\n\n```\nimport { mapGetters, mapMutations, mapActions,mapState } from \"vuex\";\nexport default {\n  computed: {\n    ...mapGetters([\n      \"playList\",  \n]),\nmethods: {\n    ...mapMutations({\n       setPlayList: \"setPlayList\"\n    }),\n    ...mapActions([\"selectPlay\"])\n  },\n}\n```\n\n####  3.页面直接使用\n\n```\nthis.playList\nthis.setPlayList(songlist);\nthis.selectPlay({\n          list: this.recommondLists,\n          index\n        })\n    },\n```\n\n```\n...mapGetters和mapState在computed中使用\n...mapAction和mapMutation 在methods中使用\n```\n\n","tags":["vuex"]},{"title":"webpack和gulp的基本介绍和使用","url":"/2019/08/24/webpack和gulp基本介绍和使用/","content":"\n### 1.gulp引入\n\n在网页开发会遇到很多静态资源，这些静态资源包括html css js image video audio jsx json svg\n随着静态资源越来越多，会存在两个问题：\na.\t静态资源过多造成网络请求过多。 把资源打包压缩合并\nb.\t静态资源之间依赖关系错综复杂。 使用模块化规范\n\n#### 1.1\tgulp是什么\n\nGulp是一个前端自动化构建工具。Gulp特点：基于任务的，同时也是基于管道流\nGulp可以帮我们完成JavaScript/sass/html/image/css 等文件的的测试、检查、合并、压缩混淆、格式化、浏览器自动刷新、部署文件生成等操作，同时可以对文件进行监听，如果文件有改动，可以自动处理生成新的文件\n\n#### 1.2\tgulp的使用步骤\n\na.全局安装gulp-cli     npm install gulp-cli –g\nb.来到项目目录下，通过npm init -y 创建package.json\nc.在项目目录下安装gulp   npm install gulp –save\nd.在项目目录下创建一个 gulpfile.js   \ne.我们可以在gulpfile.js中写gulp的任务\nf.我们可以通过gulp + 任务名字 就可以运行指定的任务了\n\n```\ngulp-concat ： 可以对js、css代码进行合并\ngulp-uglify ： 可以对js代码的压缩混淆\ngulp-cssnano ： 可以对css代码进行压缩\ngulp-htmlmin : 可以对html进行压缩\ngulp-tinypng-nokey ： 可以对图片进行压缩\n\n\n//gulp对js代码压缩合并混淆\ngulp.task(\"script\",function(){\n    return gulp.src('src/js/*.js')\n    .pipe(concat('index.js'))\n    .pipe(uglify())\n    .pipe(gulp.dest('dist/js'));\n})\n\n//gulp对css代码压缩合并\ngulp.task(\"css\",function(){\n    return gulp.src('src/css/*.css')\n    .pipe(concat('index.css'))\n    .pipe(cssnano())\n    .pipe(gulp.dest('dist/css'));\n})\n\n//gulp对html压缩\ngulp.task(\"html\",function(){\n    return gulp.src('src/a.html')\n    .pipe(htmlmin({collapseWhitespace:true}))\n    .pipe(gulp.dest('dist'));\n})\n\n//gulp对图片压缩\ngulp.task('image', function() {\n    gulp.src('./images/*.*')\n        .pipe(tinypng_nokey ())\n        .pipe(gulp.dest('./dist/images'));\n})\n\n// gulp.watch 监视文件变化，执行相应任务\ngulp.task('mywatch', function(){\n    // 1.监视js文件的变化，然后执行script任务\n    // 第一个参数：要监视的文件的规则\n    // 第二个参数：是要执行的任务\n    gulp.watch(\"src/js/*.js\",gulp.series(\"script\"))\n})\n```\n\n\n\n#### 1.3\tgulp解决浏览器缓存问题\n\n//给js文件重命名 并且输出到dist目录下\n\n```\ngulp.task('js2', () =>\n    gulp.src(['./src/js/*.js'])\n        .pipe(gulp.dest('dist')) // 将源文件拷贝到打包目录\n        .pipe(rev())    //将源文件使用hash重命名，生成新的文件\n        .pipe(gulp.dest('dist')) // 将生成新的hash文件添加到打包目录\n        .pipe(rev.manifest('js-rev.json'))\n        .pipe(gulp.dest('dist')) // 将map映射文件添加到打包目录\n);\n```\n\n//将html中的js文件用重名后的名字替换\n\n```\ngulp.task('html2', () => {\n    const jsManifest = gulp.src('dist/js-rev.json'); //获取js映射文件\n    return gulp.src('./src/a.html')\n      .pipe(revRewrite({manifest: jsManifest})) // 把引用的js替换成有版本号的名字\n      .pipe(gulp.dest('dist'))\n});\n```\n\n\n//当c.js文件发生变化之后，会重新执行js和html2的任务\ngulp.task('mywatch2', function(){\n    // 1.监视js文件的变化，然后执行script任务\n    // 第一个参数：要监视的文件的规则\n    // 第二个参数：是要执行的任务\n    return gulp.watch(\"./src/js/*.js\",gulp.series(['js2','html2']))\n})\n\n### 2.webpack\n\ngulp 是一个task runner，在gulp中我们想要完成什么功能就要写对应的task\nwebpack 是一个module bundle，在webpack中对于不同类型的文件(模块)，都会有不同的loader与之对应\n\n#### 2.1\twebpack的基本使用\n\nA．\t全局安装webpack和webpack-cli\n`npm i webpack@4.27.1 -g`\n`npm i webpack-cli@3.1.2 –g`\nB.  在项目中安装webpack\n`npm i webpack@4.27.1 --save-dev`\nC.  写对应的代码    npm install jquery\n\nD.  使用webpack的打包命令  webpack ./src/main.js -o ./dist/bundle.js\n在打包的时候会将部分的es6语法转换成es5语法(因为浏览器并不能识别所有的es6语法)\nE． 在页面上使用打包后的bundle.js就可以了\n<script src=\"../dist/bundle.js\"></script>\n#### 2.2\twebpack.config.js的创建\n\n//webpack的配置文件默认使用CommonJS的模块化方案\n//但是webpack支持各种模块化方案\n\n```\nconst path = require('path');\n\nmodule.exports = {\n  //webpack的模式 \n  //如果在开发程序的时候，模式为development\n  //如果是发布环境，模式为production\n  mode:\"development\",\n  //项目入口文件\n  entry: './src/main.js',\n  //配置输出项\n  output: {\n    path: path.resolve(__dirname, 'dist'),\n    filename: 'bundle.js'\n  },\n  //忽略打包文件超过250kb之后的警告问题\n  performance: {\n    hints: false\n  },\n};\n```\n\n接下来就可以使用webpack命令来打包构建了\n\n#### 2.3\twebpack-dev-server的使用\n\nwebpack-dev-server：主要是在项目开发的时候帮我们完成项目的自动打包构建（源代码一修改就会重新自动打包）\n//1.安装对应的包\n\n```\nnpm i webpack-dev-server@3.1.9 --save-dev\nnpm i webpack@4.27.1 --save-dev     //项目中安装webpack\nnpm i webpack-cli@3.1.2\n```\n\n//2.在package.json的script选项中配置信息如下：\n\n```\n\"scripts\": {\n    \"test\": \"echo \\\"Error: no test specified\\\" && exit 1\",\n    \"dev\": \"webpack-dev-server\"\n  }\n\n  \"dev\": \"webpack-dev-server --open --port 3001 --contentBase src --hot\"\n   // --open  自动打开浏览器\n   // --port 3001  指定webpack-dev-server开启的端口\n   // --contentBase src  指定从什么目录下加载资源\n   //  --hot  开启热更新\n```\n\n//3.我们就可以直接通过npm run dev来运行程序了\n//4.运行完之后发现页面并没有显示如我们想要的颜色，这是因为webpack-dev-server是将bundle.js放到了内存中，并没有放到磁盘的dist目录下\n//5.修改index.html中的script的引入\n <script src=\"../bundle.js\"></script>\n\n//6.在webpack.config.js中配置webpack-dev-server\n//开启热更新 步骤1：引入webpack\n\n```\nconst webpack = require('webpack'\n\n//配置devServer的参数\n  devServer: {\n    contentBase: path.join(__dirname, 'src'),\n    compress: true,\n    port: 9000,\n    open: true,\n    //开启热更新第2步：在devServer中指定hot:true\n    hot: true\n  },\n// 配置插件的节点\n  plugins: [ \n    //开启热更新第3步：指定热更新的插件\n    new webpack.HotModuleReplacem\n```\n\nentPlugin(), \n  ],\n\n#### 2.4\thtml-webpack-plugin\n\n作用：可以将html文件配置到内存，并且将打包后的bundle.js自动注入到内存中的html文件中\n\n`npm i html-webpack-plugin@3.2.0 --save-dev`\n\n// 导入自动生成HTMl文件的插件\n\n```\nvar htmlWebpackPlugin = require('html-webpack-plugin');\n```\n\n// 配置插件的节点\n\n```\n  plugins: [ \n    //开启热更新第3步：指定热更新的插件\n    new webpack.HotModuleReplacementPlugin(), \n    // 添加plugins节点配置插件\n    new htmlWebpackPlugin({\n        template:path.resolve(__dirname, 'src/index.html'),//模板路径\n        filename:'index.html'//自动生成的HTML文件的名称\n    })\n  ],\n```\n\n\n\n\n#### 2.5\tcss文件的加载器\n\n`npm i style-loader css-loader --save-dev`   加载css文件\n`npm i less-loader less`                   加载less文件\n`npm i sass-loader node-sass --save-dev`    加载scss文件\n\n```\n module: {\n        rules: [\n            {\n                test: /\\.css$Extra close brace or missing open brace/,\n                use: ['style-loader', 'css-loader'],\n            },\n            {\n                test: /\\.less$/,\n                use: ['style-loader', 'css-loader', 'less-loader']\n            },\n            {\n                test: /\\.scss$/,\n                use: [\n                    \"style-loader\", // 将 JS 字符串生成为 style 节点\n                    \"css-loader\", // 将 CSS 转化成 CommonJS 模块\n                    \"sass-loader\" // 将 Sass 编译成 CSS，默认使用 Node Sass\n                ]\n            }\n        ],\n    },\n\n```\n\nCss中有图片路径的时候，需要安装url-loader和file-loader\n\n```\nnpm i url-loader file-loader --save-dev\n```\n\n```\n{ \n                test: /\\.(png|jpg|gif|bmp|jpeg)$/, \n                use: [\n                    {\n                        loader: 'url-loader',\n                        options: {\n                            //如果图片小于8kb，会使用base64编码的图片\n                            //如果图片大于8kb，会使用带别名的图片\n                            limit: 8192,\n                            name:'[hash:8]-[name].[ext]'\n                        }\n                    }\n                ]\n            }\n```\n\n \n\n#### 2.6\t字体图标的使用\n\n```\n// 处理 字体文件的 loader\n            {   test: /\\.(ttf|eot|svg|woff|woff2)$/,\n                use: [\n                    {\n                        loader:'url-loader'\n                    }\n                ]\n            }, \n```\n\n#### 2.7\tbabel\n\nbabel 可以帮我们将es6 、es7 甚至更高版本的js语法转换成低版本的js语法，以供浏览器识别。\n//1.安装相应的包\n`npm i babel-core@6.26.3 babel-loader@7.1.5 babel-plugin-transform-runtime --save-dev`\n`npm i babel-preset-env babel-preset-stage-0 --save-dev`\n\n//2.webpack.config.js配置babel-loader\n//配置 babel 的 loader规则的时候，必须 把 node_modules 目录，通过 exclude 选项排除掉\n\n```\n            { \n​                test: /\\.js$/, \n​                use: 'babel-loader', \n​                exclude: /node_modules/ \n​            },\n\n\n```\n\n//3.在项目根目录下创建.babelrc文件\n\n```\n{\n    \"presets\": [\"env\", \"stage-0\"],\n    \"plugins\": [\"transform-runtime\"]\n}\n```\n\n","tags":["webpack"]},{"title":"HTTP协议及相关内容","url":"/2019/08/24/HTTP协议及相关内容/","content":"\n### 1. HTTP协议\n\nHTTP协议： 对客户端和服务器端之间数据传输的格式规范。\n\nHTTP协议约定的内容：\n\n```\n 请求 / 响应报文格式 \n\n 请求方法 —— GET / POST \n\n 响应状态 —— 200 / 404 / 302  / 304  \n\n 预设的请求头 / 响应头  \n```\n\nHTTP协议是基于传输层的TCP协议，在每一次客户端和服务器通信之前都会去建立tcp连接(三次握手)\n\nHTTP协议的特点：\n\n1. 无状态 \n2. 简单快速\n3. 灵活  \n\n \n\n## 1.1       请求报文\n\n请求报文：请求行 请求头 请求体\n\n![img](/img/01/clip_image002.jpg)\n\n### 1.1.1 请求行\n\n 请求行 =  请求方式 + 请求路径 + HTTP协议\n\n请求方式 ： get(获取资源) post(提交资源) put(更新资源) delete(删除资源)\n\nGET和POST区别：\n\n```\n1.GET请求是无害的(当访问同一个url的时候，所获取到的资源是同一个)\n\n多次调用POST请求会不断向服务器去提交新资源\n\n2.GET请求可以被浏览器缓存，POST请求不会被缓存\n\n3.GET请求的编码类型 application/x-www-form-urlencoded\n\nPOST请求的编码类型 application/x-www-form-urlencoded  mulipart/form-data\n\n4.GET请求会将请求参数放到url后面发到服务器，请求参数可见 \n\nPOST请求会将请求参数放到请求体里面发到服务器，请求参数在请求体里面\n\n5.GET请求的url长度有限制，最大不超过2048个字符。POST请求无长度限制\n\n6.GET请求只允许出现ASCII的字符，POST没有限制\n\n7.GET请求的安全性相对于POST请求稍差 \n```\n\n![img](/img/01/clip_image004.jpg)\n\n### 2.1.2 请求头\n\n![img](/img/01/clip_image006.jpg) \n\n### 1.1.2 请求体\n\n注意：只有POST请求才有请求体\n\n![img](/img/01/clip_image008.jpg)\n\n## 1.2       响应报文\n\n响应报文： 响应行 响应头 响应体\n\n![img](/img/01/clip_image010.jpg)\n\n### 1.2.1 响应行\n\n  响应行 = http协议 + 响应的状态码 + 响应状态码的描述       \n\n  响应状态码：  \n\n```\n 1xx：指示信息  —— 表示请求已接收，继续处理。 \n\n 2xx：成功  —— 表示请求已被成功接收、理解、接受。 \n\n 3xx：重定向  —— 要完成请求必须进行更进一步的操作。  \n\n 4xx：客户端错误  —— 请求有语法错误或请求无法实现。  \n\n 5xx：服务器端错误  —— 服务器未能实现合法的请求       \n```\n\n```\n200 OK：客户端请求成功。  /*客户端错误*/  \n\n400 Bad Request：客户端请求有语法错误，不能被服务器所理解。  \n\n401 Unauthorized：请求未经授权，这个状态代码必须和 WWW-Authenticate 报头域一起使用。 \n\n403 Forbidden：服务器收到请求，但是拒绝提供服务。  \n\n404 Not Found：请求资源不存在，举个例子：输入了错误的URL。  /*服务器错误*/  \n\n500 Internal Server Error：服务器发生不可预期的错误。 \n\n503 Server Unavailable：服务器当前不能处理客户端的请求，一段时间后可能恢复正常。     \n```\n\n### 1.2.2 响应头\n\n![img](/img/01/clip_image011.png) \n\n### 2.2.3 响应体\n\n响应体：是服务器发给客户端的真正数据\n\n![img](/img/01/clip_image013.jpg) \n\n## 1.3 HTTPS\n\nHTTP协议特点：明文传输，在客户端和服务器通信过程中，数据传输是明文。\n\nHTTPS = HTTP + SSL/TLS(加密) \n\n我们可以理解为HTTPS是安全版的HTTP\n\nHTTP端口是80\n\nHTTPS端口是443\n\n## 2.4 fildder的使用\n\n![img](/img/01/clip_image015.jpg)\n\n\n\n","tags":["HTTP"]},{"title":"前端安全性有关问题","url":"/2019/08/17/前端安全性的有关问题/","content":"\n* [XSS](#XSS)\n* [CSRF](#CSRF)\n\n#### XSS\n\n###### XSS是什么\n\n​\t\tXSS是一种经常出现在web应用中的计算机安全漏洞，它允许恶意web用户将代码植入到提供给其它用户使用的页面中。<br>\n比如这些代码包括HTML代码和客户端脚本。攻击者利用XSS漏洞旁路掉访问控制——例如同源策略(same origin policy)。<br>\n这种类型的漏洞由于被黑客用来编写危害性更大的网络钓鱼(Phishing)攻击而变得广为人知。<br>\n对于跨站脚本攻击，黑客界共识是：跨站脚本攻击是新型的“缓冲区溢出攻击“，而JavaScript是新型的“ShellCode”。\n\n```\n示例：\n<script>alert(document.cookie)</script>\n```\n\n###### 特点\n\n​\t\t能注入恶意的HTML/JavaScript代码到用户浏览的网页上，从而达到Cookie资料窃取、会话劫持、钓鱼欺骗等攻击。\n<攻击代码不一定（非要）在 <script></script> 中>\n\n###### 原因\n\n* Web浏览器本身的设计不安全。浏览器能解析和执行JS等代码，但是不会判断该数据和程序代码是否恶意。\n* 输入和输出是Web应用程序最基本的交互，而且网站的交互功能越来越丰富。如果在这过程中没有做好安全防护，很容易会出现XSS漏洞。\n* 程序员水平参差不齐，而且大都没有过正规的安全培训，没有相关的安全意识。\n* XSS攻击手段灵活多变。\n\n###### 危害\n\n* 盗取各类用户帐号，如机器登录帐号、用户网银帐号、各类管理员帐号\n* 控制企业数据，包括读取、篡改、添加、删除企业敏感数据的能力\n* 盗窃企业重要的具有商业价值的资料\n* 非法转账\n* 强制发送电子邮件\n* 网站挂马\n* 控制受害者机器向其它网站发起攻击\n\n###### 如何防范\n\n* 将重要的cookie标记为http only, 这样的话Javascript 中的document.cookie语句就不能获取到cookie了.\n* 表单数据规定值的类型，例如：年龄应为只能为int、name只能为字母数字组合。。。。\n* 对数据进行Html Encode 处理\n* 过滤或移除特殊的Html标签， 例如: <script>, <iframe> , &lt; for <, &gt; for >, &quot for\n* 过滤JavaScript 事件的标签。例如 \"onclick=\", \"onfocus\" 等等。\n\n参考资料：<br>\nhttps://www.cnblogs.com/phpstudy2015-6/p/6767032.html<br>\nhttps://www.cnblogs.com/443855539-wind/p/6055816.html<br>\nhttps://baike.baidu.com/item/XSS%E6%94%BB%E5%87%BB/954065?fr=aladdin\n\n\n#### CSRF\n\nCSRF（Cross-site request forgery）跨站请求伪造，也被称为“One Click Attack”或者Session Riding，通常缩写为CSRF或者XSRF，是一种对网站的恶意利用。尽管听起来像跨站脚本（XSS），但它与XSS非常不同，XSS利用站点内的信任用户，而CSRF则通过伪装来自受信任用户的请求来利用受信任的网站。与XSS攻击相比，CSRF攻击往往不大流行（因此对其进行防范的资源也相当稀少）和难以防范，所以被认为比XSS更具危险性。\n\n###### 特点\n\n* 依靠用户标识危害网站\n* 利用网站对用户标识的信任\n* 欺骗用户的浏览器发送HTTP请求给目标站点\n* 另外可以通过IMG标签会触发一个GET请求，可以利用它来实现CSRF攻击。\n\n###### 防御\n\n* 通过referer、token或者验证码来检测用户提交。\n* 尽量不要在页面的链接中暴露用户隐私信息。\n* 对于用户修改删除等操作最好都使用post操作 。\n* 避免全站通用的cookie，严格设置cookie的域。\n\n#####   \n\n\n\n\n\n","tags":["安全"]},{"title":"浏览器兼容性的常见问题和解决","url":"/2019/06/16/浏览器兼容性的常见问题和解决/","content":"\n#### 1.兼容性产生的原因\n\n市场上浏览器种类很多，不同浏览器的内核也不尽相同，所以各个浏览器对网页的解析存在一定的差异。\n\n#### 2.浏览器的内核\n\n浏览器内核主要分为两种，一是渲染引擎，另一个是js 引擎，内核更加倾向于说渲染引擎。\n常见的浏览器内核：\n常见的浏览器内核可以分四种：Trident、Gecko、Blink、Webkit\nIE浏览器\tTrident内核，也成为IE内核\nChrome浏览器\tWebkit内核，现在是Blink内核\nFirefox浏览器\tGecko内核，俗称Firefox内核\nSafari浏览器\tWebkit内核\nOpera浏览器\t最初是自己的Presto内核，后来加入谷歌大军，从Webkit又到了Blink内核；\n360浏览器\tIE+Chrome双内核\n猎豹浏览器\tIE+Chrome双内核\n百度浏览器\tIE内核\nQQ浏览器\tTrident（兼容模式）+Webkit（高速模式）\n\n#### 3.常见的兼容性问题\n\n1、不同浏览器的标签默认的外补丁( margin )和内补丁(padding)不同\n解决方案： css 里增加通配符 * { margin: 0; padding: 0; }\n\n2、IE6双边距问题；在 IE6中设置了float , 同时又设置margin , 就会出现边距问题\n解决方案：设置display:inline;\n\n3、当标签的高度设置小于10px，在IE6、IE7中会超出自己设置的高度\n解决方案：超出高度的标签设置overflow:hidden,或者设置line-height的值小于你的设置高度\n\n4、图片默认有间距\n解决方案：使用float 为img 布局\n\n5、IE9一下浏览器不能使用opacity\n解决方案：\nopacity: 0.5;filter: alpha(opacity = 50);filter: progid:DXImageTransform.Microsoft.Alpha(style = 0, opacity = 50);\n\n6、边距重叠问题；当相邻两个元素都设置了margin 边距时，margin 将取最大值，舍弃最小值；\n解决方案：为了不让边重叠，可以给子元素增加一个父级元素，并设置父级元素为overflow:hidden；\n\n7、cursor:hand 显示手型在safari 上不支持\n解决方案：统一使用 cursor:pointer\n\n8、两个块级元素，父元素设置了overflow:auto；子元素设置了position:relative ;且高度大于父元素，在IE6、IE7会被隐藏而不是溢出；\n解决方案：父级元素设置position:relative\n\n### 各浏览器之间的差异\n\n**1.在js中修改元素background-size样式**\n\n火狐：obj.style['backgroundSize']='XXX';\n\n谷歌及其他：obj.style['background-size']='XXX'; 或obj.style['backgroundSize']='XXX';\n\n**2.火狐无法再JS中操作float，需要在样式表中写。**\n\n**3.360浏览器这个傻逼用useragent检测出来是chrome，但是它的内核调用却是safari，太屎了！**\n\n**4.Array对象支持差异**\n\n  (1)join方法\n\n  假设有一个数组：arr={'a','b','c'}\n\n  其他浏览器：arr.join(undefind); //a,b,c\n\n  IE7:arr.join(undefind);//aundefindbundefindc\n\n  (2)indexof和lastIndexof方法\n\n  IE8及以下不支持该方法。\n\n**5.IE和FF差异**\n\n(1) window.event：\n\n表示当前的事件对象，IE有这个对象，FF没有，FF通过给事件处理函数传递事件对象\n\n(2) 获取事件源\n\nIE用srcElement获取事件源，而FF用target获取事件源\n\n(3) 添加，去除事件\n\nIE：element.attachEvent(“onclick”, function) element.detachEvent(“onclick”, function)\n\nFF：element.addEventListener(“click”, function, true) element.removeEventListener(“click”, function, true)\n\n(4) 获取标签的自定义属性\n\nIE：div1.value或div1[“value”]\n\nFF：可用div1.getAttribute(“value”)\n\n(5) document.getElementByName()和document.all[name]\n\nIE；document.getElementByName()和document.all[name]均不能获取div元素\n\nFF：可以\n\n(6) input.type的属性\n\nIE：input.type只读\n\nFF：input.type可读写\n\n(7) innerText textContent outerHTML\n\nIE：支持innerText, outerHTML\n\nFF：支持textContent\n\n(8) 是否可用id代替HTML元素\n\nIE：可以用id来代替HTML元素\n\nFF：不可以\n\n(9)document appendChild的问题\n\nIE:直接document.appendChild就可以了。\n\nFF：必须是document.body.appendChild\n\n(10)\n\nIE:var a=function abc(){alert('aa');};  a(); abc();都会弹出aa，但是 a!=abc\n\nFF:var a=function abc(){alert('aa');};  a(); abc(); a会弹出aa，abc会提示这个函数没有定义，但是 a==abc却成立。\n\n(11)\n\nIE:var tt=eval; tt('foo=1'); 如果该eval在局部作用域中且局部作用域中有foo变量且有全局变量foo，foo就会改变这个**局部foo变量**的值.\n\nFF:var tt=eval;tt('foo=1');  如果该eval在局部作用域中且局部作用域中有foo变量且有全局变量foo，foo就会改变这个**全局foo变量**的值.\n\n**6.标签的onload支持**\n\nIE下支持标签的onreadystatechange事件而不支持onload事件，且readyState有 loading loaded complete三个值。\n\n其余浏览器支持onload事件而不支持onreadystatechange事件\n\nopera则都支持。\n\n **7.自定义属性支持**\n\nIE：如果是自定义属性，写在行间也是没有问题的，如 <img ff=\"1\"/>\n\n除IE内核之外的浏览器：OPERA FF CHROME 不支持行间自定义属性， 只有写在javascript里，如 ： oImg[\"ff\"]=1;\n\n**8.input button 标签去border后的样式**\n\nchrome:为了显示按钮的立体感，它会故意把按钮向规定的坐标下置1px\n\n##### ff 和 IE 的脚本兼容问题\n\n```\n1、在 IE 下和火狐下事件冒泡不一样\n//阻止冒泡的兼容性写法\nfunction stopBubble(event){\n    var e=arguments.callee.caller.arguments[0]||event;\n    if(e&&e.stopPropagation){\n        e.stopPropagation()\n    }else if(window.event){\n    \t//ie\n        window.event.cancelBubble=true;\n    }\n}\n\n\n//阻止浏览器默认行为的兼容性写法\nfunction stopDefault(event){\n    var e=arguments.callee.caller.arguments[0]||event;\n    //阻止默认浏览器动作(W3C)\n    if(e&&e.preventDefault){\n        e.preventDefault();\n    }else{\n        //IE中阻止函数默认动作的方式\n        window.event.returnValue=false;      \n    }\n    return false;\n}\n\n\n2、IE 的写法： tbody=table.childNodes[0]\n\t在 FF 中，firefox 会在子节点中包含空白则第一个子节点为空白\"\"， 而 ie 不会返回空白\n\t可以通过 if(\"\" != node.nodeName)过滤掉空白子对象\n\n3、模拟点击事件\nif(document.all){ //ie 下\n\tdocument.getElementById(\"a3\").click();\n}\nelse{ //非 IE\n\tvar evt = document.createEvent(\"MouseEvents\");\n\tevt.initEvent(\"click\", true, true);\n\tdocument.getElementById(\"a3\").dispatchEvent(evt);\n}\n\n4、事件注册\nif (isIE){\n   window.attachEvent(\"onload\", init);\n}else{\n   window.addEventListener(\"load\", function(){})\n\n5、ajax对象的获取\n   IE： ActiveXObject\n   其他浏览器：XMLHttpRequest\n```\n\n","tags":["兼容性"]},{"title":"React之使用Apache服务器进行项目上线","url":"/2019/05/15/React之使用Apache服务器进行项目上线 /","content":"\n#### 1.第一步\n\n在package.json里加 \"homepage\":\".\" （否则路径会发生错误）\n\n项目npm run build 生成build目录\n\n#### 2.第二步\n\n解压Apache\n\n![img](/img/01/Apache.png) \n\n在Apache的bin目录下执行：httpd -t 查看是否出错\n\n#### 3.第三步（以下均在服务器端操作）\n\n修改Apache下的conf下的httpd.conf配置文件\n\n37行 Define SRVROOT \"E:/Apache\"\n\n39行 ServerRoot \"E:/Apache\"\n\n59行 \\#Listen 12.34.56.78:80\n\n60行  Listen 8030\n\n142行  LoadModule proxy_module modules/mod_proxy.so\n\n151行  LoadModule proxy_http_module modules/mod_proxy_http.so\n\n 225行 ServerName localhost:8888\n\n 233行 Options Indexes FollowSymLinks\n\n  234行 AllowOverride None\n\n  235行 Order allow,deny\n\n  236行 Allow from all\n\n  251行  DocumentRoot \"C:\\\\\"\n\n  252行  <Directory \"C:\\\\\">\n\n#### 4.第四步\n\n​\t把build中的文件拷贝到E:/webapp中\n\n#### 5.第五步\n\n​    在Apache的bin目录下执行：\n\n​     安装：$ httpd.exe -k install -n \"Apache\"\n\n​\t  卸载：$ httpd.exe -k uninstall -n \"Apache\"\n\n​      Win+R: services.msc启动或停止Apache服务器。\n\n####   6.第六步\n\n​       在浏览器中输入localhost:8030查看网页显示\n\n####   7.第七步(可允许多个项目)\n\n​\t\t配置Apache虚拟目录（允许Apache运行多个项目）\n\n​        509行： \\# Virtual hosts\n\n​         510行：Include conf/extra/httpd-vhosts.conf（打开）\n\n####   8.第八步(配置反向代理)\n\n```\n  <VirtualHost *:8030> \n    DocumentRoot \"C:/webapp3\"\n\t<Directory \"C:/webapp3\">\n\t\tOptions FollowSymLinks Indexes \n\t\tAllowOverride none\n\t\tRequire all granted\n\t</Directory>\n\tProxyrequests off\n\t<Proxy *>\n\t\t#规定Deny,Allow的执行顺序, Order Deny,Allow ： 先执行Deny，再执行Allow\n        Order Deny,Allow\n        #全部禁止访问 取值：all none 指定ip\n        Allow from All\n\t</Proxy>\n        #配置反向代理\n\t\tProxyPass /api http://172.24.42.8:3001/api     (服务器ip)\n\t\tProxyPass /IPShare http://ip.360.cn/IPShare\t\n</VirtualHost>\n\n```\n\n注意：\n\n在C:\\Windows\\System32\\drivers\\etc的hosts中添加\n\n​             172.24.42.8(服务器ip)     smallan.top（域名）\n\n####  9.访问\n\n​\t         smllant.top:8030\n\n","tags":["上线"]},{"title":"React之生命周期的介绍","url":"/2019/04/15/React之生命周期的介绍/","content":"\n### react组件的生命周期\n\nReact组件的生命周期分为三个阶段：组件的创建阶段、组件的运行阶段、组件的销毁阶段\n\n#### 1.组件的创建阶段\n\n    //1.生命周期第一个执行的是静态属性(只会执行一次)\n    //  静态属性：设置props的初始值(在使用当前组件的时候，没有给当前组件传递props的时候，该初始值会生效)\n    static defaultProps = {\n        initcount: 1000\n    }\n    static propTypes = {\n        // 使用 prop-types 包 来定义 initcount 为 number 类型\n        // isRequired 表示这个props属性是必须要传递的\n        initcount: ReactTypes.number.isRequired\n    }\n    \n    //2.生命周期第二个执行的是constructor 构造函数 (执行一次)\n    // 在创建组件对象的时候会自动调用构造函数\n    constructor(props) {\n        console.log(\"constructor\")\n        super(props)\n        //在构造函数中指定组件的私有数据\n        this.state = {\n            count: props.initcount\n        }\n        this.divRef = React.createRef()\n    }\n    \n    //3.当子组件接收到新的props会执行,在react16.4版本以后，setState修改state数据之后也会触发这个方法(执行多次)\n    // 在该方法中不能通过this.setSate来修改state数据,因为在staic修饰的方法中就没有this\n    //作用：将传递的props映射到state里面\n    //参数： nextProps 外部传递过来的props属性\n    //      prevState 之前的state状态\n    static getDerivedStateFromProps(nextProps, prevState) {\n        console.log(\"getDerivedStateFromProps\", nextProps, prevState)\n        //获取到父组件中传递过来的initcount值\n        const { initcount } = nextProps;\n        //当父组件中传递过来的initcount发生改变了\n        if (initcount != prevState.prevCount) {\n            //在方法中返回{count:initcount} 替换掉当前state中的 count值\n            return {\n                count: initcount,\n                prevCount:initcount\n            }\n        }\n        //如果父组件中传递过来的initcount没有变化，就返回一个空对象(此时不对当前的state做任何修改)\n        return null\n    }\n    \n    //4.创建虚拟dom，但是虚拟dom还没有挂载到页面 (执行多次)\n    // render函数中不能使用setState()来修改state的数据，因为会死循环\n    render() {\n        console.log(\"render\", this.divRef.current)  //null\n        return (<div ref={this.divRef}>\n            哈哈Counter {this.state.count}\n        </div>)\n    }\n    \n    //5.虚拟dom已经挂载到页面，此时可以获取到最新的页面 (执行一次)\n    componentDidMount() {\n        console.log(\"componentDidMount\", this.divRef.current, this.state)  //null\n    }\n\n#### 2.组件运行阶段\n\n    // 第一个会执行：static getDerivedStateFromProps\n    // 当父组件给子组件传递的props发生变化的时候，会执行该方法。\n    // 在react16.4版本以后，当前组件的state发生变化，会触发forceUpdate方法，然后还是会触发该方法\n    \n    // 第二个会执行: shouldComponentUpdate\n    // 在这个函数中，我们可以设置指定条件下去更新页面，指定条件下不更新页面。这个函数中入参props和state都是最新的\n    // 在该方法中不能通过this.setSate来修改state数据\n    shouldComponentUpdate(nextProps, nextState) {\n        console.log(\"shouldComponentUpdate\", nextProps, nextState)\n        // 在 shouldComponentUpdate 中要求必须返回一个布尔值\n        // 在 shouldComponentUpdate 中，如果返回的值是 false，则不会继续执行后续的生命周期函数，而是直接退回到了运行中的状态，此时后续的render函数并没有被调用，因此页面不会被更新，但是组件的 state 状态，却被修改了；\n        // return nextState.count % 2 == 0 ? true : false;\n        return true;\n    }\n    \n    //第三个会执行:render  此时会重新构建虚拟dom，但是新的虚拟dom还没有渲染到页面\n    \n    //第四个会执行getSnapshotBeforeUpdate 函数\n    // 在该方法中不能通过this.setSate来修改state数据\n    getSnapshotBeforeUpdate() {\n        console.log(\"getSnapshotBeforeUpdate\")\n        return {}\n    }\n    \n    //第五个执行componentDidUpdate 函数\n    // 在该方法中不能通过this.setSate来修改state数据\n    //表示组件已经更新完毕  此时可以获取到最新的页面\n    componentDidUpdate() {\n        console.log(\"componentDidUpdate\", this.state)\n    }\n\n#### 3.组件的销毁阶段\n\n```\ncomponentWillUnmount() {\n    console.log(\"componentWillUnmount\")\n}\n```\n\n\n    //很关键的，我们获取当前rootNode的scrollHeight，传到componentDidUpdate 的参数perScrollHeight\n    //在render方法调用之后，在componentDidUpdate之前执行，我们可以在这个方法中获取到元素的滚动位置的信息\n    //还可以在该方法中做一些样式的微调\n    getSnapshotBeforeUpdate() {\n        //console.log(this.rootNode.clientHeight)\n        //this.rootNode.style.backgroundColor = \"red\";\n        return this.rootNode.scrollHeight;\n    }\n\n\n\n ","tags":["React"]},{"title":"数据库之Mongodb的使用","url":"/2019/03/16/数据库之Mongodb的使用/","content":"\n### 数据库的介绍\n\n#### 1.1\t保存数据的方案\n\n数据在内存  优点：读取数据非常快    缺点：一旦程序关系，数据丢失\n数据在文件  优点：文件可以持久保存  缺点：修改数据频繁覆盖文件\n数据在数据库  优点：持久保存 管理数据很方便\n\n#### 1.2\t数据库的分类\n\n关系型数据库：Oracle   Mysql   Sqlserver  DB2 。数据存在硬盘，查询会相对慢\n非关系型数据库：Mongodb  Redis  HBase。数据在内存，查询会比较快，适合海量数据。\n\n### Mongodb的介绍\n\nMongodb : 最像关系型数据库的非关系型数据库\n\n关系型数据库：\n1.\t数据库\n2.\t表\n3.\t表数据\n\nMongodb：\n1.\t数据库\n2.\t集合\n3.\t文档\n\n#### 1.mongodb安装\n\n​\t点击安装包傻瓜式的安装  注意不要勾选 compass \n​\t安装完毕之后配置环境变量\n\n​\t在c盘根目录下创建data/db文件夹\n​\t使用mongod命令来启动mongdb数据库。端口：27017\n\n​\t安装nosqlbooster\n \t使用nosqlbooster连接mongodb数据库\n\n​\t在nosqlbooster中写命令\n\n#### 2.mongodb的常用命令\n\n```\nshow dbs  //显示当前mongodb中的所有数据库\n\nuse igeek //切换当前正在使用的数据库\n\ndb.student.insert({_id:1,name:\"test\"})  //向当前数据库的student集合中插入一条数据\ndb.student.insert({name:\"tom\"})    //向当前数据库的student集合中插入一条数据，id随机\ndb.student.remove({name: \"tom\"})   //删除当前数据库的student集合中的name为tom的数据\n\ndb.student.update({name:\"kk\"},{ $set: { name:\"kkk\" } },{ upsert:true,multi:true })   \n//upsert:true  如果在更新的时候没有该数据则会插入一条数据  \n//multi:true   如果有多个name为kk的数据，多个数据都会发生变化\n\n//如果save()传了id参数，并且id值在原数据库中存在，则会修改数据库中的数据。如果不存在，则会新建一条数据\ndb.student.save({_id:ObjectId(\"5cf336d51ff4541f8c5bb63e\"),name:\"gg\",hobbies:[\"足球\",\"篮球\"]})\n\n//此时save()方法没有传入id参数，就会在数据库的表中新建一条数据\ndb.student.save({name:\"ll\",hobbies:[\"足球\",\"篮球\"]})\n\nshow collections     //显示当前数据库下的所有集合\ndb.student.find()    //查询当前数据库student集合下的所有数据\ndb.dropDatabase()    //删除当前数据库\n\ndb.createCollection(\"animal\")     //在当前数据库下新建一个集合\ndb.animal.drop()                  //删除当前数据库下的animal集合\n```\n\n#### 3.mongodb的查询操作\n\n```\nmongoimport –d 数据库的文字 –c 集合的名字 文件名  \n\ndb.student.find()     查询当前数据库下的student表的所有内容\n\n//查询姓名是李灵黛的student\ndb.student.find({name:\"李灵黛\"})\n\n//查询指定id的学生(id是唯一的)\ndb.student.find({_id:ObjectId(\"5cf33cf6a7ba70e3fa58a8e0\")})\n\n//查询名字是李念儿的并且年龄是19的人\ndb.student.find({name:\"李念儿\",age:19})\n\n//查询名字是李念儿 或者 年龄是19的\ndb.student.find({$or:[{name:\"李念儿\"},{age:19}]})\n\n//查询年龄大于30的\ndb.student.find({age:{$Extra close brace or missing open bracegt:30}})\n//查询年龄大于等于30的\ndb.student.find({age:{$gte:30}})\n//查询年龄小于30的\ndb.student.find({age:{$Extra close brace or missing open bracelt:30}})\n//查询年龄小于等于30的\ndb.student.find({age:{$lte:30}})\n//查询年龄等于30的\ndb.student.find({age:30})\n//查询年龄不等于13的\ndb.student.find({age:{$ne:13}})\n\n//跳过前面1条数据，获取两条数据(可以来做分页查询)\ndb.student.find().limit(2).skip(1)\n\n//按照年龄排序  -1降序  1升序\ndb.student.find().sort({age:-1})\n\n//求所有年龄的和\n//mongodb中聚合查询 $sum  $avg  $min  $max  $first  $last\n//在mongodb中做聚合查询用aggregate()函数\n//聚合查询：可以对一组数据进行查询  得到一个结果\ndb.student.aggregate( [\n   {\n     $group: {\n        _id: null,\n        total: { $sum: \"$age\" }\n     }\n   }\n] )\n\n//求所有年龄的平均数\ndb.student.aggregate( [\n   {\n     $group: {\n        _id: null,\n        total: { $avg: \"$age\" }\n     }\n   }\n] )\n\n//求第一个年龄\ndb.student.aggregate( [\n   {\n     $group: {\n        _id: null,\n        total: { $first: \"$age\" }\n     }\n   }\n] )\n```\n\n#### 4. mongoose的使用\n\nhttps://mongoosejs.com/docs/api/model.html\n\n```\n//1.引入mongoose\nvar mongoose = require('mongoose');\n//2.连接mongdb数据库\nmongoose.connect('mongodb://localhost:27017/igeek',{useNewUrlParser:true});\n//3.获取连接对象\nvar db = mongoose.connection;\n//4.连接数据库出错的回调\ndb.on('error', console.error.bind(console, 'connection error:'));\n//5.连接数据库成功的回调\ndb.once('open', function() {\n  console.log(\"已连接数据库\")\n});\n//6.创建一个Scheme.这个Scheme是和数据库的集合对应的\n//mongoose ： ORM框架   Object Relational Mapping 对象关系映射\n//Model  Student\nvar studentSchema = new mongoose.Schema({\n    name: String,\n    age: Number,\n    sex: String,\n    province: String\n });\n//7.创建一个Model  就和数据库中的students表关联\nvar Student = mongoose.model('Student', studentSchema);\n\n//8.查询数据库\napp.get(\"/index\",(req,res)=>{\n    //Model.find() 来查数据\n    Student.find()\n    .then(function(data){\n        res.json(data);\n    },function(err){\n        res.send(\"err\");\n    })\n}) \n```\n\n#### 5.mongoose的常用方法\n\n```\napp.get(\"/index\",(req,res)=>{\n    //Model.find() 查询所有数据\n    // Student.find()\n    // .then(function(data){\n    //     res.json(data);\n    // },function(err){\n    //     res.send(\"err\");\n    // })\n```\n\n\n\n    //Model.find({name:\"zhangsan\"}) 根据条件查询数据(返回所有符合条件的数据 数组)\n    // Student.find({name:\"小明\"})\n    // .then(function(data){\n    //     res.json(data);\n    // },function(err){\n    //     res.send(\"err\");\n    // })\n    \n    //Model.findOne({})  查询符合条件的数据(只返回一条)\n    // Student.findOne({name:\"小明\"})\n    // .then(function(data){\n    //     res.json(data);\n    // },function(err){\n    //     res.send(\"err\");\n    // })\n    \n    //Student.findById(\"\") 根据主键查询指定信息\n    // Student.findById(\"5da57082de29900f18144831\")\n    // .then(function(data){\n    //     res.json(data);\n    // })\n    \n    //Student.findByIdAndUpdate(\"\")  根据id找，找到之后修改\n    // Student.findByIdAndUpdate(\"5da57082de29900f18144831\",{$set:{name:\"tt\"}})\n    // .then(function(data){\n    //     res.json(data);\n    // })\n    \n    //Student.findByIdAndDelete(\"\")  根据id找，找到之后删除\n    // Student.findByIdAndDelete(\"5da57082de29900f18144831\")\n    // .then(function(data){\n    //     //data删除的那个元素\n    //     res.json(data);\n    // })\n    \n    // Student.findOne({$or:[{name:\"小明\"},{age:23}]})  两个条件有任何一个满足返回结果\n    // Student.findOne({$or:[{name:\"小明\"},{age:23}]})\n    // .then(function(data){\n    //     res.json(data);\n    // })\n    \n    // 分页查询\n    // Student.find()\n    // .skip(1)\n    // .limit(2)\n    // .then(function(data){\n    //     res.json(data);\n    // })\n    \n    // 找age>1 并且age<110的\n    // Student.find({age: {$gte: 1, $lte: 110}})\n    // .then(function(data){\n    //     res.json(data);\n    // })\n    \n    //where来指定查询条件\n    // Student\n    // .where(\"age\").gte(1).lte(110)\n    // .where(\"name\",\"小明\")\n    // .then(function(data){\n    //     res.json(data);\n    // })\n\n\n    Student.update({name:\"小明\"},{$set:{name:\"xiaohuang\"}})\n    .then(function(data){\n        //修改成功的一些状态信息\n        res.json(data);\n    },function(err){\n        console.log(err);\n    })\n    })\n    \n    向数据库新增一个学生\n    app.get(\"/addStu\",(req,res)=>{\n        var stu = new Student({\n            _id: new mongoose.Types.ObjectId(),\n            name: \"小白\",\n            age: 20,\n            email: \"11@qq.com\",\n            birthday: new Date(),\n            adult: false,\n            message: [{address:\"无锡\"},12,\"我是帅哥\"],\n            hobbies: [\"足球\",\"篮球\"],\n            scores: [{subject: \"语文\",score:66},{subject: \"数学\",score:99}],\n            sex:1\n        });\n        //Model对象.save() 入库\n        stu.save()\n        .then(function(data){\n            //保存数据成功之后会将保存成功的用户返回来\n            res.json(data);\n        },function(err){\n            res.json(err);\n        })\n    })\n    ","tags":["数据库"]},{"title":"ES6新特性之函数的新变化","url":"/2018/05/04/ES6新特性之函数的新变化/","content":"\n####  1.函数参数的扩展\n\n######  默认参数\n\n 基本用法：\n\n```\nfunction fn(name,age=17){\nconsole.log(name+\",\"+age);\n}\nfn(\"Amy\",18);  // Amy,18\nfn(\"Amy\",\"\");  // Amy,\nfn(\"Amy\");     // Amy,17\n```\n\n注意点：使用函数默认参数时，不允许有同名参数。\n\n```\n// 不报错\nfunction fn(name,name){\n console.log(name);\n}\n// 报错\n//SyntaxError: Duplicate parameter name not allowed in this context\nfunction fn(name,name,age=17){\n console.log(name+\",\"+age);\n}\n```\n\n\n只有在未传递参数，或者参数为 undefined 时，才会使用默认参数，null 值被认为是有效的值传递。\n\n```\nfunction fn(name,age=17){\n    console.log(name+\",\"+age);\n}\nfn(\"Amy\",null); // Amy,null\n函数参数默认值存在暂时性死区，在函数参数默认值表达式中，还未初始化赋值的参数值无法作为其他参数的默认值。\n\nfunction f(x,y=x){\n    console.log(x,y);\n}\nf(1);  // 1 1\n\nfunction f(x=y){\n    console.log(x);\n}\nf();  // ReferenceError: y is not defined\n```\n\n###### 不定参数\n\n不定参数用来表示不确定参数个数，形如，...变量名，由...加上一个具名参数标识符组成。具名参数只能放在参数组的最后，并且有且只有一个不定参数。\n\n基本用法\n\n```\nfunction f(...values){\n    console.log(values.length);\n}\nf(1,2);      //2\nf(1,2,3,4);  //4\n```\n\n#### 2.箭头函数\n\n箭头函数提供了一种更加简洁的函数书写方式。基本语法是：\n\n```\n参数 => 函数体\n基本用法：\nvar f = v => v;\n//等价于\nvar f = function(a){\n return a;\n}\nf(1);  //1\n```\n\n\n当箭头函数没有参数或者有多个参数，要用 () 括起来。\n\n```\nvar f = (a,b) => a+b;\nf(6,2);  //8\n```\n\n\n当箭头函数函数体有多行语句，用 {} 包裹起来，表示代码块，当只有一行语句，并且需要返回结果时，可以省略 {} , 结果会自动返回。\n\n```\nvar f = (a,b) => {\n let result = a+b;\n return result;\n}\nf(6,2);  // 8\n```\n\n\n当箭头函数要返回对象的时候，为了区分于代码块，要用 () 将对象包裹起来\n\n```\n// 报错\nvar f = (id,name) => {id: id, name: name};\nf(6,2);  // SyntaxError: Unexpected token :\n\n// 不报错\nvar f = (id,name) => ({id: id, name: name});\nf(6,2);  // {id: 6, name: 2}\n```\n\n\n注意点：没有 this、super、arguments 和 new.target 绑定。\n\n```\nvar func = () => {\n  // 箭头函数里面没有 this 对象，\n  // 此时的 this 是外层的 this 对象，即 Window \n  console.log(this)\n}\nfunc(55)  // Window \n\nvar func = () => {    \n  console.log(arguments)\n}\nfunc(55);  // ReferenceError: arguments is not defined\n```\n\n\n箭头函数体中的 this 对象，是定义函数时的对象，而不是使用函数时的对象。\n\n```\nfunction fn(){\n  setTimeout(()=>{\n    // 定义时，this 绑定的是 fn 中的 this 对象\n    console.log(this.a);\n  },0)\n}\nvar a = 20;\n// fn 的 this 对象为 {a: 19}\nfn.call({a: 18});  // 18\n```\n\n\n不可以作为构造函数，也就是不能使用 new 命令，否则会报错\n\n适合使用的场景\nES6 之前，JavaScript 的 this 对象一直很令人头大，回调函数，经常看到 var self = this 这样的代码，为了将外部 this 传递到回调函数中，那么有了箭头函数，就不需要这样做了，直接使用 this 就行。\n\n```\n// 回调函数\nvar Person = {\n    'age': 18,\n    'sayHello': function () {\n      setTimeout(function () {\n        console.log(this.age);\n      });\n    }\n};\nvar age = 20;\nPerson.sayHello();  // 20\n\nvar Person1 = {\n    'age': 18,\n    'sayHello': function () {\n      setTimeout(()=>{\n        console.log(this.age);\n      });\n    }\n};\nvar age = 20;\nPerson1.sayHello();  // 18\n```\n\n\n所以，当我们需要维护一个 this 上下文的时候，就可以使用箭头函数。\n\n不适合使用的场景\n定义函数的方法，且该方法中包含 this\n\n```\nvar Person = {\n    'age': 18,\n    'sayHello': ()=>{\n        console.log(this.age);\n      }\n};\nvar age = 20;\nPerson.sayHello();  // 20\n// 此时 this 指向的是全局对象\n\nvar Person1 = {\n    'age': 18,\n    'sayHello': function () {\n        console.log(this.age);\n    }\n};\nvar age = 20;\nPerson1.sayHello();   // 18\n// 此时的 this 指向 Person1 对象\n需要动态 this 的时候\n\nvar button = document.getElementById('userClick');\nbutton.addEventListener('click', () => {\n     this.classList.toggle('on');\n});\n```\n\n\nbutton 的监听函数是箭头函数，所以监听函数里面的 this 指向的是定义的时候外层的 this 对象，即 Window，导致无法操作到被点击的按钮对象。\n\n\n\n\n\n\n\n##### \n\n","tags":["ES6"]},{"title":"ES6新特性之解决异步问题的方案","url":"/2018/05/03/ES6新特性之解决异步问题的方案/","content":"\n####  1.使用回调函数解决异步问题\n\n```\nfunction eat(callback){\n    console.log(\"吃饭\");\n    setTimeout(() => {\n        callback();\n    }, 3000);\n}\n\nfunction sing(){\n    console.log(\"唱歌\")\n}\n\neat(sign);\n```\n\n#### 2.使用Promise解决异步问题\n\n```\nnew Promise(function (resolve, reject) {\n    setTimeout(() => {\n        console.log('吃饭')\n        resolve('吃好饭了')\n    }, 3000)\n}).then(function (msg) {\n    console.log(msg, '去唱歌')\n})\n```\n\n#### 3.使用async和await解决异步问题\n\n```\nasync是用来修饰方法的,加上async修饰的方法有三个作用\n1.在该方法内部可以使用await关键字\n2.该方法需要会默认返回一个Promise\n3.加async修饰的方法表示异步方法，不会堵塞当前线程的执行\n\nawait是用来等待Promise执行的结果的，await后面需要跟一个Promise\n1.可以将原来的异步变成同步任务\n2.只可以在async修饰的方法中使用\n```\n\n以读取文件为例\n\n```\nconst fs = require('fs');\n\nfunction myread(path){\n    return new Promise(function(resolve,reject){\n        fs.readFile(path,function(err,data){\n            resolve(data.toString())\n        })\n    })\n}\n\nasync function test1(){\n    //这边是堵塞了，按照串行化执行\n    let result1 =  await myread(\"./a.json\");\n    console.log(result1)\n    let result2 =  await myread(\"./b.json\");\n    console.log(result2)\n    let result3 =  await myread(\"./c.json\");\n    console.log(result3)\n}\n\ntest1()\n.then(function(msg){\n    console.log(msg)\n});\n\n```\n\n","tags":["ES6"]},{"title":"ES6新特性之Promise的介绍","url":"/2018/04/29/ES6新特性之Promise的介绍/","content":"\n####  1.Promise的概念\n\n \t\t所谓 Promise，就是一个对象，用来传递异步操作的消息。它代表了某个未来才会知道结果的事件（通常是一个异步操作），并且这个事件提供统一的 API，可供进一步处理。\n\n​\tpromise 有三个状态：\n\n```\n1.正在进行中   Pending\n2.成功          Resolved  当在promise中显示调用resolve()的时候，此时promise的状态被改变，对应promise后的then的第一个function就会执行了\n3.失败          Rejected  当在promise中显示调用reject()的时候，此时promise的状态被改变，对应promise后的then的第二个function就会执行了\n```\n\n#### 2.Promise的作用\n\n​\t\tPromise的出现主要是解决地狱回调的问题，比如你需要结果需要请求很多个接口，这些接口的参数需要另外那个的接口返回的数据作为依赖，这样就需要我们一层嵌套一层，但是有了Promise 我们就无需嵌套。\n\n​\t\t 注意：Promise本身不是异步的(Promise中的function会立马执行)，只不过Promise中可以有异步任务，当异步任务的执行有结果之后，我们通过resolve和reject来改变promise的状态，当promise的状态改变之后此时promise的then就会执行了\n\n#### 3.使用Promise读取文件举例\n\n```\nconst fs = require('fs');\nconsole.log(\"1\")   //----1\n//promise中的function是立马执行的\nvar promise = new Promise(function(resolve,reject){\n    console.log(\"2\")   //----2\n    //读取文件操作\nfs.readFile(\"./aa.json\",function(err,data){\n    console.log(\"3\");\n    //读取文件失败\n    if(err){\n        //当文件读取失败之后，会自动执行promise的then的第二个function\n        reject(\"错了,文件不存在\");\n        return;\n    }\n    //当文件读取成功之后，会自动执行promise的then的第一个function\n    resolve(data.toString())\n})\n})\npromise.then(function(msg){\n    console.log(\"4\",msg);\n},function(msg){\n    console.log(\"6\",msg);\n})\nconsole.log(\"5\") \n```\n\n#### 4.Promise链\n\n```\n  promise.then(function(){\n     return new Promise(...)\n   }).then(function(){\n     return new Promise(..)\n   }).then(function(){\n   })\n```\n\n举例\n\n```\nconsole.log(1)   \nnew Promise(function(resolve,reject){\n    console.log(2)  \n    setTimeout(() => {\n        resolve();\n    }, 2000);\n}).then(function(){\n    return new Promise(function(resolve,reject){\n        console.log(3)\n        setTimeout(() => {\n            resolve()\n        }, 2000);\n    });\n\n}).then(function(msg){\n    console.log(4,msg)\n},function(msg){\n    console.log(6,msg)\n})\nconsole.log(5) \n```\n\n当一个Promise完成（fulfilled）或者失败（rejected），返回函数将被异步调用（由当前的线程循环来调度完成）。具体的返回值依据以下规则返回：\n•\t如果then中的回调函数返回一个值，那么then返回的Promise将会成为接受状态，并且将返回的值作为接受状态的回调函数的参数值。\n•\t如果then中的回调函数没有返回值，那么then返回的Promise将会成为接受状态，并且该接受状态的回调函数的参数值为 undefined。\n•\t如果then中的回调函数抛出一个错误，那么then返回的Promise将会成为拒绝状态，并且将抛出的错误作为拒绝状态的回调函数的参数值。\n•\t如果then中的回调函数返回一个已经是接受状态的Promise，那么then返回的Promise也会成为接受状态，并且将那个Promise的接受状态的回调函数的参数值作为该被返回的Promise的接受状态回调函数的参数值。\n•\t如果then中的回调函数返回一个已经是拒绝状态的Promise，那么then返回的Promise也会成为拒绝状态，并且将那个Promise的拒绝状态的回调函数的参数值作为该被返回的Promise的拒绝状态回调函数的参数值。\n•\t如果then中的回调函数返回一个未定状态（pending）的Promise，那么then返回Promise的状态也是未定的，并且它的终态与那个Promise的终态相同；同时，它变为终态时调用的回调函数参数与那个Promise变为终态时的回调函数的参数是相同的。\n\n#### 5.Promise的异常处理\n\n```\nconst fs = require('fs');\nfunction myread(path){\n    return new Promise(function(resolve,reject){\n        fs.readFile(path,function(err,data){\n            if(err){\n                reject(err);\n                return;\n            }\n            resolve(data.toString())\n        })\n    })\n}\n\nmyread('./a.json')\n.then(function(msg){\n    console.log(msg);\n    return myread('./b.json')\n})\n.then(function(msg){\n    console.log(msg);\n    return myread('./c.json')\n})\n.then(function(msg){\n    return myread('./d.json')\n})\n.then(function(msg){\n    console.log(msg,\"aaa\")\n},function(err){\n    console.log(err,\"ddd\");\n    throw new Error(err);\n})\n.catch(function(err){\n    console.log(\"处理了异常\",err);\n})\n```\n\n\n\n#### 5.Promise.all和Promise.race\n\n举例\n\n```\nvar promise1 = new Promise(function(resolve,reject){\n    setTimeout(function(){\n        resolve(\"P1\");\n    },2000);\n})\n\nvar promise2 = new Promise(function(resolve,reject){\n    setTimeout(function(){\n        resolve(\"P2\");\n    },3000);\n})\n\n//Promise.rece([p1,p2])  promise参数数组中的任何一个promise执行完毕之后立马执行then\n//Promise.all([p1,p2]).then的函数的参数是最早执行的promise的结果\nPromise.race([promise1,promise2])\n.then(function(msg){\n    console.log(msg);\n})\n```\n\n//Promise.all([p1,p2])  会等all参数数组中的所有promise都执行完毕之后再执行then\n//Promise.all([p1,p2]).then的函数的参数是一个数组参数，会将所有promise执行的结果放到这个数组参数中\n\n//Promise.race([p1,p2])  promise参数数组中的任何一个promise执行完毕之后立马执行then\n//Promise.all([p1,p2]).then的函数的参数是最早执行的promise的结果","tags":["ES6"]},{"title":"ES6新特性之模板字面量","url":"/2018/04/28/ES6新特性之模板字面量/","content":"\n####  1.模板字面量介绍\n\n```\n模板字面量 是允许嵌入表达式的字符串字面量。你可以使用多行字符串和字符串插值功能。它们在ES2015规范的先前版本中被称为“模板字符串”。\n```\n\n####  2.模板字面量的描述\n\n模板字符串使用反引号 (` `) 来代替普通字符串中的用双引号和单引号。模板字符串可以包含特定语法（`${expression}`）的占位符。占位符中的表达式和周围的文本会一起传递给一个默认函数，该函数负责将所有的部分连接起来，如果一个模板字符串由表达式开头，则该字符串被称为带标签的模板字符串，该表达式通常是一个函数，它会在模板字符串处理后被调用，在输出最终结果前，你都可以通过该函数来对模板字符串进行操作处理。在模版字符串内使用反引号（`）时，需要在它前面加转义符（\\）。\n\n```js\n`\\`` === \"`\" // --> true\n```\n\n####  3.多行字符串\n\n在新行中插入的任何字符都是模板字符串中的一部分，使用普通字符串，你可以通过以下的方式获得多行字符串：\n\n```js\nconsole.log('string text line 1\\n' +\n'string text line 2');\n// \"string text line 1\n// string text line 2\"\n```\n\n要获得同样效果的多行字符串，只需使用如下代码：\n\n```js\nconsole.log(`string text line 1\nstring text line 2`);\n// \"string text line 1\n// string text line 2\"\n```\n\n####  4.插入表达式\n\n在普通字符串中嵌入表达式，必须使用如下语法：\n\n```js\nvar a = 5;\nvar b = 10;\nconsole.log('Fifteen is ' + (a + b) + ' and\\nnot ' + (2 * a + b) + '.');\n// \"Fifteen is 15 and\n// not 20.\"\n```\n\n现在通过模板字符串，我们可以使用一种更优雅的方式来表示：\n\n```js\nvar a = 5;\nvar b = 10;\nconsole.log(`Fifteen is ${a + b} and\nnot ${2 * a + b}.`);\n// \"Fifteen is 15 and\n// not 20.\"\n```\n\n#### 5.嵌套模板\n\n在某些时候，嵌套模板是具有可配置字符串的最简单也是更可读的方法。 在模板中，只需在模板内的占位符 `${ }` 内使用它们，就可以轻松地使用内部反引号。 例如，如果条件 a 是真的，那么返回这个模板化的文字。\n\nES5:\n\n```js\nvar classes = 'header'\nclasses += (isLargeScreen() ?\n   '' : item.isCollapsed ?\n     ' icon-expander' : ' icon-collapser');\n```\n\n在ES2015中使用模板文字而没有嵌套：\n\n```js\nconst classes = `header ${ isLargeScreen() ? '' :\n    (item.isCollapsed ? 'icon-expander' : 'icon-collapser') }`;\n```\n\n在ES2015的嵌套模板字面量中： \n\n```js\nconst classes = `header ${ isLargeScreen() ? '' :\n `icon-${item.isCollapsed ? 'expander' : 'collapser'}` }`;\n```\n\n#### 6.带标签的模板字符串\n\n更高级的形式的模板字符串是带标签的模板字符串。标签使您可以用函数解析模板字符串。标签函数的第一个参数包含一个字符串值的数组。其余的参数与表达式相关。最后，你的函数可以返回处理好的的字符串（或者它可以返回完全不同的东西 , 如下个例子所述）。用于该标签的函数的名称可以被命名为任何名字。\n\n```js\nvar person = 'Mike';\nvar age = 28;\n\nfunction myTag(strings, personExp, ageExp) {\n\n  var str0 = strings[0]; // \"that \"\n  var str1 = strings[1]; // \" is a \"\n\n  // There is technically a string after\n  // the final expression (in our example),\n  // but it is empty (\"\"), so disregard.\n  // var str2 = strings[2];\n\n  var ageStr;\n  if (ageExp > 99){\n    ageStr = 'centenarian';\n  } else {\n    ageStr = 'youngster';\n  }\n\n  return str0 + personExp + str1 + ageStr;\n\n}\n\nvar output = myTag`that ${ person } is a ${ age }`;\n\nconsole.log(output);\n// that Mike is a youngster\n```\n\n正如下面例子所展示的，标签函数并不一定需要返回一个字符串。\n\n```js\nfunction template(strings, ...keys) {\n  return (function(...values) {\n    var dict = values[values.length - 1] || {};\n    var result = [strings[0]];\n    keys.forEach(function(key, i) {\n      var value = Number.isInteger(key) ? values[key] : dict[key];\n      result.push(value, strings[i + 1]);\n    });\n    return result.join('');\n  });\n}\n\nvar t1Closure = template`${0}${1}${0}!`;\nt1Closure('Y', 'A');  // \"YAY!\" \nvar t2Closure = template`${0} ${'foo'}!`;\nt2Closure('Hello', {foo: 'World'});  // \"Hello World!\"\n```\n\n#### 7.原始字符串\n\n在标签函数的第一个参数中，存在一个特殊的属性`raw` ，我们可以通过它来访问模板字符串的原始字符串，而不经过特殊字符的替换。\n\n```js\nfunction tag(strings) {\n  console.log(strings.raw[0]);\n}\n\ntag`string text line 1 \\n string text line 2`;\n// logs \"string text line 1 \\n string text line 2\" ,\n// including the two characters '\\' and 'n'\n```\n\n另外，使用[`String.raw()`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/raw) 方法创建原始字符串和使用默认模板函数和字符串连接创建是一样的。\n\n```js\nvar str = String.raw`Hi\\n${2+3}!`;\n// \"Hi\\n5!\"\n\nstr.length;\n// 6\n\nstr.split('').join(',');\n// \"H,i,\\,n,5,!\"\n```\n\n#### 8.带标签的模版字面量及转义序列\n\n自ES2016起，带标签的模版字面量遵守以下转义序列的规则：\n\n- Unicode字符以\"\\u\"开头，例如`\\u00A9`\n- Unicode码位用\"\\u{}\"表示，例如`\\u{2F804}`\n- 十六进制以\"\\x\"开头，例如`\\xA9`\n- 八进制以\"\\\"和数字开头，例如`\\251`\n\n这表示类似下面这种带标签的模版是有问题的，因为对于每一个ECMAScript语法，解析器都会去查找有效的转义序列，但是只能得到这是一个形式错误的语法：\n\n```js\nlatex`\\unicode`\n// 在较老的ECMAScript版本中报错（ES2016及更早）\n// SyntaxError: malformed Unicode character escape sequence\n```\n\n#### 9.ES2018关于非法转义序列的修订\n\n带标签的模版字符串应该允许嵌套支持常见转义序列的语言（例如[DSLs](https://en.wikipedia.org/wiki/Domain-specific_language)、[LaTeX](https://en.wikipedia.org/wiki/LaTeX)）。ECMAScript提议[模版字面量修订](https://tc39.github.io/proposal-template-literal-revision/)(第4阶段，将要集成到ECMAScript 2018标准) 移除对ECMAScript在带标签的模版字符串中转义序列的语法限制。\n\n不过，非法转义序列在\"cooked\"当中仍然会体现出来。它们将以 [`undefined`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/undefined) 元素的形式存在于\"cooked\"之中：\n\n```js\nfunction latex(str) { \n return { \"cooked\": str[0], \"raw\": str.raw[0] }\n} \n\nlatex`\\unicode`\n\n// { cooked: undefined, raw: \"\\\\unicode\" }\n```\n\n值得注意的是，这一转义序列限制只对带标签的模板字面量移除，而不包括不带标签的模板字面量：\n\n```js\nlet bad = `bad escape sequence: \\unicode`;\n```\n\n\n\n\n\n","tags":["ES6"]},{"title":"ES6新特性之变量及解构赋值","url":"/2018/04/25/ES6新特性之变量及解构赋值/","content":"\n####  1.ES6介绍\n\n```\nECMAScript 6.0（以下简称ES6）是JavaScript语言的下一代标准，已经在2015年6月正式发布了。它的目标，是使得JavaScript语言可以用来编写复杂的大型应用程序，成为企业级开发语言。\n```\n\n####  2.关于变量\n\n###### var:\n\n1.只有全局作用域变量和函数作用域变量\n2.“变量提升”\n\n###### let:\n\n1、没有变量的提升，必须先声明后使用\n\n2、let声明的变量，不能与前面的let，var，conset声明的变量重名\n\n3、定义块级作用域变量\n\n###### const ： 定义只读变量\n\n1、const声明变量的同时必须赋值，const声明的变量必须初始化，一旦初始化完毕就不允许修改\n2、const声明变量也是一个块级作用域变量\n3、const声明的变量没有“变量的提升”，必须先声明后使用\n4、const声明的变量不能与前面的let， var ，  const声明的变量重名\n\n####  3.解构赋值\n\n###### 对象的解构赋值：\n\n```\n    //对象解构：对象解构不需要位置和数组解构位置一致，只要保证解构的变量名和属性一致即可。\n     let {a,c}={c:4,a:2};\n     console.log(a,c);\n     //如果解构失败，变量赋值为undefined.\n     let {acd}={f:2};\n     console.log(acd);\n```\n\n- 对象解构还有一个常用的功能，就是取js的一些方法，类似python的反射功能。\n\n```\n // 我们在使用对象解构的时候，可以获取对应的对象的方法类似有点想python的反射\n     let {log}=console;\n     log(222);\n      //对象解构 上面的例子都是简写形式。实际上是如下：//也就是说：a是匹配的关键字 而真正的白能量是c.\n     let {a:c}={a:2,c:4};\n     console.log(c)\n```\n\n- 对象解构嵌套解构对象，这种情况下对应嵌套的解构匹配属性不能省略。\n\n```\n   //在解构的时候，我们也可以用在解构中嵌套解构对象，也就是说可以在对象解构中嵌套数组解构 这种情况嵌套对象的属性不能省略匹配的同名属性。\n    let {ac:ac,ff:[c,a]}={ac:22,ff:[1,2]};\n    console.log(ac,c,a);\n```\n\n###### 数组的解构赋值：\n\n```\n   //解构赋值：通过数组对应，对变量进行对应赋值。\n    let [a,c,v,b]=[1,2,3,4];\n    console.log(a,c,v,b);\n    //这种赋值叫做 模式匹配。只要等号两边结构一样就可以进行赋值。\n    let [k,[[n],d]]=[1,[[2],3]];\n    console.log(k,n,d);\n    //如果解构不成功，对应变量值为undefined;\n    let [l,m]=[1];\n    console.log(m);\n    //不完全解构，如果等号左边没有全部匹配右边也是可以结构成功的。\n    let [vv,vb,vc]=[1,2,3,4];\n    console.log(vv,vb,vc);\n    //变量结构需要等号右边需要itrator结构，也就是说具备可以被迭代。否则解构不成功。\n    try {\n        // let [cc]=2;//右边并不是数组 TypeError: 2 is not iterable\n        let [dd]={};//不具备iteraor 所以解构也不成功。TypeError: {} is not iterable\n    }catch (e) {\n        console.log(e)\n    }\n```\n\n```\n// 解构允许有默认值。\n    let [a1,a2=2]=[1];\n    console.log(a1,a2);\n    // 需要注意的是在es6内部使用的是严格相等来判断一个位置是否有值。只有当数组中的成员严格等于undefined 默认值才能生效。\n    // 如果默认值里是null，因为null不严格等于undefined 所有默认值也不会生效。\n    let  [a=2]=[null];\n    console.log(a);//a=null\n    // 如果默认值是表达式，这个表达式是惰性求值。只有用到的时候才会求值。\n    fn=()=>{\n      return 2;\n    };\n    let [a=fn()]=[1];\nconsole.log(a);\n//只有a对应的右边的位置的值为undefined的时候，才会执行fn，否则不会执行相当于：\nlet x;\nx=[1][0]===undefined?fn():[1][0];//只有在对应的右边的元素为undefined的时候才会计算表达式。和函数的默认为表达式也是惰性求值。\n```\n\n```\n// 默认值也可以是其他结构解构的变量，但是对应的变量需要提前声明，否则会报错。\n    try {\n        let [ov,oc=ov]=[1];\n        console.log(ov,oc);\n        let [k1=k2,k2]=[undefined,2];\n        console.log(k1,k2);//ReferenceError: Cannot access 'k2' before initialization\n    }catch (e) {\n        console.log(e)\n    }\n```\n\n\n\n","tags":["ES6"]},{"title":"css3新特性之canvas画布","url":"/2017/09/26/css3新特性之canvas画布/","content":"\n1.\t### canvas的使用步骤\n \n   ```\n   1. <!--创建一个canvas标签，并且指定他（画布）的大小-->\n       <canvas id=\"mycanvas\" width=\"200\" height=\"200\" style=\"border: 1px solid red;\"></canvas>\n   \n   \n      var canavas = document.getElementById(\"mycanvas\");\n       //1.拿到绘图上下文\n       var context = canavas.getContext(\"2d\");\n       //2.画图\n       context.beginPath();\n       context.strokeStyle = \"blue\";\n       context.lineWidth = 5;\n       context.moveTo(50, 50);\n       context.lineTo(200,50);\n       context.stroke();\n   ```\n\n### 2.canvas的常用方法和属性\n\n```\n\t//开启一条新的路径\n   context.beginPath();\n   //闭合路径\n   context.closePath()\n     //设置描边的颜色\n     context.strokeStyle = \"blue\";\n     //设置填充的颜色\n     context.fillStyle = \"red\";\n     //设置线和线之间的连接点的样式:miter(默认)、round、bevel\n     context.lineJoin = \"miter\"\n     //stroke表示描边\n     context.stroke();\n     //fill表示填充\n     context.fill();\n   //设置线帽的样式：(butt默认)、round、square \n     context.lineCap = \"round\";\n   //设置虚线：实线20 虚线20 实线20 虚线20 ...\n     ctx.setLineDash([20]);\n     //设置虚线：实线10 虚线20 实线10 虚线20 ...\n     ctx.setLineDash([10,20]);\n     //设置虚线：实线10 虚线20 实线30 虚线10 实线20 虚线30...\n     ctx.setLineDash([10,20,30]);\n     console.log(ctx.getLineDash());\n     /*\n     lineDashOffset:\n     如果是正数，设置的偏移是画线的反方向的偏移\n     如果是负数，设置的偏移是画线的方向的偏移\n     */\n     ctx.lineDashOffset= -10;\n\n\n```\n\n\n\n```\n非0环绕法则：\n   /*\n    在使用ctx.fill()判断哪个区域要不要填充的时候遵循的是非零环绕的规则：\n    1.从需要判断是否要填充的区域开始随便拉一条线出去\n    2.看所有和拉出去的那条线相交的点，方向顺时针+1，逆时针-1\n    3.看上面第二步+1 和 -1后的结果。如果结果是0，则不填充。如果结果不是0，则填充\n    */\n```\n\n\n\n### 3.基本图形绘制\n\n```\n //自动描边的react\n   ctx.strokeRect(100.5, 100.5, 200, 200);\n\n   //手动描边的react\n   ctx.rect(100.5, 100.5, 200, 200);\n   ctx.stroke();\n\n   //自动填充的react\n   ctx.fillRect(100.5, 100.5, 200, 200);\n\n   //清除指定区域的绘制的图像\n   ctx.clearRect(0,0,ctx.canvas.width,ctx.canvas.height);\n\n//创建一个渐变的区域\n    var linearGradient = ctx.createLinearGradient(100,100,500,100);\n    linearGradient.addColorStop(0,'pink');\n    linearGradient.addColorStop(0.5,'red');\n    linearGradient.addColorStop(1,'blue');\n    ctx.fillStyle = linearGradient;\n\n //arc(圆心x,圆心y,半径,起始角度,终止角度,顺时针 false/逆时针 true)\n    ctx.arc(150, 150, 100, 0, Math.PI/2, false);\n    ctx.stroke();\n```\n\n\n\n    //绘制扇形\n    ctx.beginPath();\n    ctx.moveTo(300,300);\n    ctx.arc(300, 300, 100, 0, Math.PI/4, false);\n    ctx.closePath();\n    ctx.stroke();  \n\n```\n ctx.beginPath();\n    ctx.strokeStyle = '#000';\n    /*有文本的属性  尺寸 字体  左右对齐方式  垂直对齐的方式*/\n    ctx.font = '40px Microsoft YaHei';\n    /*左右对齐方式 (center left right start end) 基准起始坐标*/\n    ctx.textAlign = 'center';\n    /*垂直对齐的方式 基线 baseline(top,bottom,middle) 基准起始坐标*/\n    ctx.textBaseline = 'middle';\n    var x0 = w / 2 - 0.5;\n    var y0 = h / 2 - 0.5;\n    //绘制文字\n    var str = \"您吃-,了吗\";\n    //填充文本\n    ctx.fillText(str, x0, y0)\n    //描边文本\n    // ctx.strokeText(str,x0,y0)\n```\n\n    /*获取文本的宽度*/\n    console.log(ctx.measureText(str).width);\n\n```\n//将canvas的绘图状态保存一份\n    ctx.save();\n //还原canvas之前保存的状态\n    ctx.restore();\n\n\nvar image = new Image();\n    image.src = \"./image/01.jpg\";\n    image.onload = function(){\n        //三个参数：drawImage(图片对象,绘制在画布上的坐标 x y)\n        // ctx.drawImage(image,100,100);\n```\n\n\n\n\n        //五个参数：drawImage(图片对象,绘制在画布上的坐标 x y,图片的绘制尺寸 会缩放)\n        //ctx.drawImage(image,100,100,100,50);\n    \n        //九个参数: drawImage(图片对象,图片中的一个矩形区域 x y w h,画布中的一个矩形区域 x1 y1 w1 h1)\n        //ctx.drawImage(image,0,0,228,220,100,100,100,100);\n    }\n\n\n    //ctx.translate(100,100);   //让坐标系平移100,100(坐标系原点会发生变化)\n    //ctx.scale(0.5,1);         //让坐标系x方向缩放0.5 (坐标系刻度会发生变化)\n    //ctx.rotate(Math.PI/6);    //跟随坐标系原点旋转30°！\n","tags":["canvas"]},{"title":"css3新特性之过渡动画和关键帧动画","url":"/2017/09/25/css3新特性之过渡动画和关键帧动画/","content":"\n#### 1.transition过渡动画\n\ntransition : 由一种状态到另外一种状态之间进行过渡的时候产生动画效果\n\n /* 需要添加动画的属性 不需要双引号，如果有多个属性要进行动画，中间用逗号隔开;如果该属性不写，则默认给所有属性添加动画 */   \n\n```\n transition-property: width,height;\n            /*动画的持续时间*/\n            transition-duration: 3s;\n            /*动画的运动方式*/\n            transition-timing-function: ease;\n            /*动画延迟时间*/\n            transition-delay: 1s;\n```\n\n /*复合属性*/\n\n```\n    transition: width 3s linear 0s,height 3s linear 1s;\n```\n\n\n\n#### 2.animation动画\n\nanimation：关键帧动画，一种状态到另一种状态再到另一种状态\n\n```\n .box:hover{\n            /*鼠标悬停的时候添加动画*/\n            animation-name: anim;\n            animation-duration: 4s;\n            animation-delay: 1s;\n            animation-timing-function: linear;\n            /*动画播放完的状态:forwards:保持动画播放完毕后的状态 backwards:退回到原始状态(默认值)*/\n            animation-fill-mode: forwards;\n            /*动画播放的次数*/\n            /* animation-iteration-count: 10; */\n            /*动画交叉执行*/\n            animation-direction:alternate ;\n        }\n         .box:active{\n        /*控制动画是否暂停*/\n        animation-play-state: running;\n        animation-play-state: paused;\n    }\n```\n\n   \n\n/*声明一个关键帧动画 ：我们这边只有两帧\n          动画的名字就叫：anim\n     \n\n```\n   */\n        @keyframes anim {\n            /* from{ \n                width: 100px;\n            }  \n            to{ \n                width: 300px;\n            }   */\n              0%{\n            /*可以同时对多个属性添加动画效果*/\n            transform: rotate(0deg) scale(1);\n        }\n        50%{\n            transform: rotate(180deg) scale(2);\n        }\n        100%{\n            transform: rotate(360deg) scale(1);\n        }\n    }\n```\n\n复合属性：\n\n```\n  animation: name duration timing-function delay iteration-count direction fill-mode;  \n```\n\n","tags":["动画"]},{"title":"css3新特性之弹性布局Flex","url":"/2017/09/24/css3新特性之弹性布局Flex/","content":"\n####   1.flex基本概念\n\n​\t采用Flex布局的元素，称为Flex容器（flex container），简称”容器”。它的所有子元素自动成为容器成员，称为Flex项目（flex item），简称”项目”。\n\n#### 2.容器的基本属性\n\n##### （1）flex-direction：决定主轴的方向（父级使用）\n\n​        row（默认值）：主轴为水平方向，起点在左端。\n\n​        row-reverse：主轴为水平方向，起点在右端。\n\n​        column：主轴为垂直方向，起点在上沿。\n\n​        column-reverse：主轴为垂直方向，起点在下沿。\n\n##### （2）flex-wrap：一条轴线排不下，如何换行（父级使用）\n\n​\t      nowrap(默认)：不换行\n\n​           wrap:换行，第一行在上方\n\n​           wrap-reverse:换行，第一行在下方\n\n##### （3）flex-flow：flex-flow属性是flex-direction属性和flex-wrap属性的简写形式，\n\n​         默认值为row nowrap\n\n##### （4）justify-content：项目在主轴上的对齐方式\n\n​        flex-start（默认值）：左对齐\n\n​\t\tflex-end：右对齐\n\n​\t\tcenter： 居中\n\n​\t\tspace-between：两端对齐，项目之间的间隔都相等。\n\n​\t\tspace-around：每个项目两侧的间隔相等\n\n##### （5）align-items：项目在交叉轴上如何对齐(纵轴)\n\n​         flex-start：交叉轴的起点对齐。\n\n​\t\tflex-end：交叉轴的终点对齐。\n\n​\t\tcenter：交叉轴的中点对齐。\n\n​\t\tbaseline: 项目的第一行文字的基线对齐。\n\n​\t\tstretch（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度。\n\n#####  （6）align-content：多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用\n\n​\t\tflex-start：与交叉轴的起点对齐。\n\n​\t\tflex-end：与交叉轴的终点对齐。\n\n​\t\tcenter：与交叉轴的中点对齐。\n\n​\t\tspace-between：与交叉轴两端对齐，轴线之间的间隔平均分布。\n\n​\t\tspace-around：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。\n\n​\t\tstretch（默认值）：轴线占满整个交叉轴。\n\n#### 3.项目的基本属性\n\n​\t（1）order：项目的排列顺序。数值越小，排列越靠前，默认为0\n\n​    （2）flex-grow：定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大\n\n​    （3）flex-shrink：定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。\n\n​\t（4）flex-basis：定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小。\n\n​    （5）flex：flex属性是flex-grow、flex-shrink、flex-basis的缩写，默认值为0 1 auto\n\n​\t（6）align-self：属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch","tags":["Flex布局"]},{"title":"HTML5新特性","url":"/2017/09/08/HTML5新特性/","content":"\n####   1.语义化标签\n\n   　　语义化标签使得页面的内容结构化，见名知义\n\n| 标签                  |               描述               |\n| --------------------- | :------------------------------: |\n| <header></header>     |       定义了文档的头部区域       |\n| <footer></footer>     |       定义了文档的尾部区域       |\n| <nav></nav>           |          定义文档的导航          |\n| <section></section>   | 定义文档中的节（section、区段）  |\n| <article></article>   |      定义页面独立的内容区域      |\n| <aside></aside>       |       定义页面的侧边栏内容       |\n| <detailes></detailes> | 用于描述文档或文档某个部分的细节 |\n| <summary></summary>   |   标签包含 details 元素的标题    |\n| <dialog></dialog>     |      定义对话框，比如提示框      |\n\n#### 2.增强型表单\n\nHTML5 拥有多个新的表单 Input 输入类型。这些新特性提供了更好的输入控制和验证。\n\n| 输入类型       | 描述                         |\n| -------------- | ---------------------------- |\n| color          | 主要用于选取颜色             |\n| date           | 从一个日期选择器选择一个日期 |\n| datetime       | 选择一个日期（UTC 时间）     |\n| datetime-local | 选择一个日期和时间 (无时区)  |\n| email          | 包含 e-mail 地址的输入域     |\n| month          | 选择一个月份                 |\n| number         | 数值的输入域                 |\n| range          | 一定范围内数字值的输入域     |\n| search         | 用于搜索域                   |\n| tel            | 定义输入电话号码字段         |\n| time           | 选择一个时间                 |\n| url            | URL 地址的输入域             |\n| week           | 选择周和年                   |\n\n```\n用户名：<input type=\"text\" name=\"userName\"> <br>\n密码：<input type=\"password\" name=\"userPwd\"> <br>\n<!--email提供了默认的电子邮箱的完整验证：要求必须包含@符号，同时必须包含服务器名称，如果不能满足验证，则会阻止当前的数据提交-->\n邮箱：<input type=\"email\"> <br>\n<!--tel它并不是来实现验证。它的本质目的是为了能够在移动端打开数字键盘。意味着数字键盘限制了用户只能输入数字。  如何查看效果：qq发送文件>>手机端使用qq来接收>>使用手机浏览器查看-->\n电话：<input type=\"tel\"> <br>\n<!--验证只能输入合法的网址：必须包含http://-->\n网址：<input type=\"url\"> <br>\n<!--number：只能输入数字(包含小数点)，不能输入其它的字符\nmax:最大值\nmin:最小值\nvalue:默认值-->\n数量：<input type=\"number\" value=\"60\" max=\"100\" min=\"0\"> <br>\n<!--search：可以提供更人性化的输入体验-->\n请输入商品名称：<input type=\"search\"> <br>\n<!--range:范围-->\n范围：<input type=\"range\" max=\"100\" min=\"0\" value=\"50\"> <br>\n颜色：<input type=\"color\"> <br>\n<!--日期时间相关-->\n<!--time:时间：时分秒-->\n时间：<input type=\"time\"> <br>\n<!--date：日期：年月日-->\n日期：<input type=\"date\"> <br>\n<!--datetime:大多数浏览器不能支持datetime.用于屏幕阅读器-->\n日期时间：<input type=\"datetime\"><br>\n<!--datetime-local:日期和时间-->\n日期时间：<input type=\"datetime-local\" value=\"2017-06-30T00:00\"> <br>\n月份：<input type=\"month\"> <br>\n星期：<input type=\"week\">\n<!--提交-->\n<input type=\"submit\">\n```\n\n#### 3.视频和音频\n\n\n```\n<audio controls autoplay=\"autoplay\">\n    <source src=\"./mp3/aa.mp3\">   \n\n    <source src=\"./mp3/aa.wav\">   \n\n    <source src=\"./mp3/aa.ogg\"> \n\n    您的浏览器不支持音频播放功能    \n\n</audio>\n```\n\n \n\n\n```\n<video controls autoplay width=\"600px\" height=\"400px\">\n\n    <source src=\"./mp3/mp4.mp4\"/>\n\n    <source src=\"./mp3/mp4.ogg\"/>\n\n    您的浏览器不支持视频播放功能  \n\n</video>\n```\n\n#### 4.dom元素扩展\n\n​    classList 元素的样式的集合    \n\n```\na) Node.classList.add('class') 添加class    \n\nb) Node.classList.remove('class') 移除class    \n\nc) Node.classList.toggle('class') 切换class，有则移除，无则添加    \n\nd) Node.classList.contains('class')检测是否存在class   \n```\n\n#### 5.  本地存储\n\n​       sessionStorage的使用：存储数据到本地。存储的容量5mb左右。  \n\n​        1.这个数据本质是存储在当前页面的内存中-意味着新开的页面和新开的浏览器无法获取数据 \n\n​        2.它的生命周期为关闭当前页面，关闭页面，数据会自动清除         \n\n​        3.如果当前页面显示的内容发生改变之后，sessionStorage数据仍然在 \n\n​                  setItem(key,value):存储数据，以键值对的方式存储        \n\n​                  getItem(key):获取数据，通过指定名称的key获取对应的value值     \n\n​                  removeItem(key):删除数据，通过指定名称key删除对应的值      \n\n​                  clear():清空所有存储的内容           \n\n​       localStorage的使用：  存储的内容大概20mb  不同浏览器不能共享数据。但是在同一个浏览器的不同窗口中可以共享数据  永久生效，它的数据是存储在硬盘上，并不会随着页面或者浏览器的关闭而清除.如果想清除，必须手动清除  \n\n​               setItem(key,value):存储数据，以键值对的方式存储  \n\n​               getItem(key):获取数据，通过指定名称的key获取对应的value值\n\n​               removeItem(key):删除数据，通过指定名称key删除对应的值  \n\n​               clear():清空所有存储的内容          \n\n​              sessionStorage 和 localStorage在存和取的时候操作的都是字符串     \n\n","tags":["HTML5"]},{"title":"正则表达式的使用","url":"/2017/08/04/正则表达式的使用/","content":"\n#### 1.正则表达式常用示例\n\n```\n一、校验数字的表达式\n数字：^[0-9]*$\nn位的数字：^\\d{n}$\n至少n位的数字：^\\d{n,}$\nm-n位的数字：^\\d{m,n}$\n零和非零开头的数字：^(0|[1-9][0-9]*)$\n非零开头的最多带两位小数的数字：^([1-9][0-9]*)+(.[0-9]{1,2})?$\n带1-2位小数的正数或负数：^(\\-)?\\d+(\\.\\d{1,2})?$\n正数、负数、和小数：^(\\-|\\+)?\\d+(\\.\\d+)?$\n有两位小数的正实数：^[0-9]+(.[0-9]{2})?$\n有1~3位小数的正实数：^[0-9]+(.[0-9]{1,3})?$\n非零的正整数：^[1-9]\\d*$ 或 ^([1-9][0-9]*){1,3}$ 或 ^\\+?[1-9][0-9]*$\n非零的负整数：^\\-[1-9][]0-9\"*$ 或 ^-[1-9]\\d*$\n非负整数：^\\d+$ 或 ^[1-9]\\d*|0$\n非正整数：^-[1-9]\\d*|0$ 或 ^((-\\d+)|(0+))$\n\n二、校验字符的表达式\n汉字：^[\\u4e00-\\u9fa5]{0,}$\n英文和数字：^[A-Za-z0-9]+$ 或 ^[A-Za-z0-9]{4,40}$\n长度为3-20的所有字符：^.{3,20}$\n由26个英文字母组成的字符串：^[A-Za-z]+$\n由26个大写英文字母组成的字符串：^[A-Z]+$\n由26个小写英文字母组成的字符串：^[a-z]+$\n由数字和26个英文字母组成的字符串：^[A-Za-z0-9]+$\n由数字、26个英文字母或者下划线组成的字符串：^\\w+$ 或 ^\\w{3,20}$\n中文、英文、数字包括下划线：^[\\u4E00-\\u9FA5A-Za-z0-9_]+$\n中文、英文、数字但不包括下划线等符号：^[\\u4E00-\\u9FA5A-Za-z0-9]+$ 或 ^[\\u4E00-\\u9FA5A-Za-z0-9]{2,20}$\n可以输入含有^%&',;=?$\\\"等字符：[^%&',;=?$\\x22]+\n禁止输入含有~的字符：[^~\\x22]+\n\n三、特殊需求表达式\nEmail地址：^\\w+([-+.]\\w+)*@\\w+([-.]\\w+)*\\.\\w+([-.]\\w+)*$\n域名：[a-zA-Z0-9][-a-zA-Z0-9]{0,62}(/.[a-zA-Z0-9][-a-zA-Z0-9]{0,62})+/.?\nInternetURL：[a-zA-z]+://[^\\s]* 或 ^http://([\\w-]+\\.)+[\\w-]+(/[\\w-./?%&=]*)?$\n手机号码：^(13[0-9]|14[5|7]|15[0|1|2|3|5|6|7|8|9]|18[0|1|2|3|5|6|7|8|9])\\d{8}$\n电话号码(\"XXX-XXXXXXX\"、\"XXXX-XXXXXXXX\"、\"XXX-XXXXXXX\"、\"XXX-XXXXXXXX\"、\"XXXXXXX\"和\"XXXXXXXX)：^(\\(\\d{3,4}-)|\\d{3.4}-)?\\d{7,8}$ \n国内电话号码(0511-4405222、021-87888822)：\\d{3}-\\d{8}|\\d{4}-\\d{7}\n身份证号：\n15或18位身份证：^\\d{15}|\\d{18}$\n15位身份证：^[1-9]\\d{7}((0\\d)|(1[0-2]))(([0|1|2]\\d)|3[0-1])\\d{3}$\n18位身份证：^[1-9]\\d{5}[1-9]\\d{3}((0\\d)|(1[0-2]))(([0|1|2]\\d)|3[0-1])\\d{4}$\n短身份证号码(数字、字母x结尾)：^([0-9]){7,18}(x|X)?$ 或 ^\\d{8,18}|[0-9x]{8,18}|[0-9X]{8,18}?$\n帐号是否合法(字母开头，允许5-16字节，允许字母数字下划线)：^[a-zA-Z][a-zA-Z0-9_]{4,15}$\n密码(以字母开头，长度在6~18之间，只能包含字母、数字和下划线)：^[a-zA-Z]\\w{5,17}$\n强密码(必须包含大小写字母和数字的组合，不能使用特殊字符，长度在8-10之间)：^(?=.*\\d)(?=.*[a-z])(?=.*[A-Z]).{8,10}$ \n日期格式：^\\d{4}-\\d{1,2}-\\d{1,2}\n一年的12个月(01～09和1～12)：^(0?[1-9]|1[0-2])$\n一个月的31天(01～09和1～31)：^((0?[1-9])|((1|2)[0-9])|30|31)$ \n中文字符的正则表达式：[\\u4e00-\\u9fa5]\n空白行的正则表达式：\\n\\s*\\r (可以用来删除空白行)\nHTML标记的正则表达式：<(\\S*?)[^>]*>.*?</\\1>|<.*? /> (网上流传的版本太糟糕，上面这个也仅仅能部分，对于复杂的嵌套标记依旧无能为力)\n首尾空白字符的正则表达式：^\\s*|\\s*$或(^\\s*)|(\\s*$) (可以用来删除行首行尾的空白字符(包括空格、制表符、换页符等等)，非常有用的表达式)\n腾讯QQ号：[1-9][0-9]{4,} (腾讯QQ号从10000开始)\n中国邮政编码：[1-9]\\d{5}(?!\\d) (中国邮政编码为6位数字)\nIP地址：\\d+\\.\\d+\\.\\d+\\.\\d+ (提取IP地址时有用)\n```\n\n#### 2.各个字符说明和描述\n\n![img](/img/01/zengze1.png) \n\n![img](/img/01/zengze2.png) \n\n\n\n","tags":["RegExp"]},{"title":"javaScript之浅拷贝及深拷贝的实现","url":"/2017/06/12/javaScript之浅拷贝及深拷贝的实现/","content":"\n### 1.浅拷贝及深拷贝的介绍\n\n浅拷贝是拷贝一层，深层次的对象级别的就拷贝引用（这时引用更改，其拷贝值也会跟着更改）\n\n深拷贝是拷贝多层，每一级别的数据都会拷贝出来；\n\n浅拷贝的时候如果数据是基本数据类型，那么就如同直接赋值那种，会拷贝其本身，如果除了基本数据类型之外还有一层对象，那么对于浅拷贝而言就只能拷贝其引用，对象的改变会反应到拷贝对象上；但是深拷贝就会拷贝多层，即使是嵌套了对象，也会都拷贝出来。\n\n### 2.浅拷贝的实现\n\n```\n<script>\n    var obj = {\n        name:'小蚂蚁',\n        age: 26,\n        sex:'male',\n        arr:[1,2,3]\n    }\n    var obj1 = {};\n    function clone(origin,target){\n        var target = target ||{};\n        for(var prop in origin){\n            target[prop] = origin[prop];\n        }\n        return target;\n    }\n    clone(obj,obj1);\n</script>\n```\n\n### 3.深拷贝的实现\n\n```\n1.遍历对象 for(var prop in obj)\n2.判断是不是原始值 typeof()   object\n3.判断是数组还是对象 instanceof Object.prototype.toString.call constructor\n4.建立相应的数组或对象\n5.递归实现\n```\n\n```\n<script>\n    var obj = {\n        name:'小蚂蚁',\n        age:12,\n        arr:[1,2,3,4]\n    }\n    var obj1  = {};\n   function deepClone(origin,target){\n       var target = target ||{};\n       var toStr = Object.prototype.toString;\n       var arrStr = '[object Array]';\n\n       for(var prop in origin){\n           if(origin.hasOwnProperty(prop)){//避免拿原型链上的属性\n            if(origin[prop]!==\"null\"&&typeof(origin[prop])=='object'){//引用值\n              if(toStr.call(origin[prop])==arrStr){\n                   target [prop] = [];\n               } else{\n                   target[prop] = {}\n               }\n               deepClone(origin[prop],target[prop])\n            }else{//原始值\n                target[prop] = origin[prop];\n            }\n           }\n       }\n       return target;\n   }\n</script>\n```\n\n","tags":["javaScript"]},{"title":"javaScript之原型及原型链","url":"/2017/06/04/javaScript之原型及原型链/","content":"\n### 1.原型介绍\n\n1.\tprototype作用：存放构造函数的所有实例共享的信息\n2.\t如何给函数添加原型信息\n函数名.prototype.属性名字=？\n函数名.prototype.方法名字=？\n3.\t原型属性/原型方法  和 实例属性/实例方法的区别？\na)\t原型属性和原型方法是添加在函数.prototype里面的，拥有者是函数.prototype\nb)\t实例属性和实例方法是添加在对象本身上面的，拥有者是对象本身\nc)\t虽然原型属性和原型方法的拥有者是函数的. Prototype,但是这些信息是可以被所有的实例共享的 \n\n\n3.\t__proto__和prototype\n函数的prototype：叫显示原型，他本身也是一个对象，作用是存放构造函数的所有实例共享的信息\n对象的__proto__ ： 叫隐式原型，这个属性不是标准属性，是给浏览器用的一个属性,他指向函数的prototype\n\n\n对象.__proto__ == 函数.prototype\n\n在函数prototype中有三部分信息：分别是\n\n```\n1.\t构造器       他指向函数本身\n2.\t所有实例共享的属性和方法   \n3.\t__proto__     它指向父亲的.prototype\n```\n\n### 2.原型链\n\n原型链的核心就是依赖对象的_proto_的指向，当自身不存在的属性时，就一层层的扒出创建对象的构造函数，直至到Object时，就没有_proto_指向了。\n\n```\n对象.__proto__ == 函数.prototype;\n  Person.prototype.constructor == Person;\n  Person.prototype.__proto__ == Object.prototype;\n  Object.prototype.__proto__ == null\n```\n\n![img](/img/01/yuanxin.webp) \n\n### 3.new一个对象经历了什么\n\n```\nfunction Test(){}\nconst test = new Test()\n```\n\n1. 创建一个新对象：\n\n```\nconst obj = {}\n```\n\n2. 设置新对象的constructor属性为构造函数的名称，设置新对象的`__proto__`属性指向构造函数的prototype对象\n\n```\nobj.constructor = Test\nobj.__proto__ = Test.prototype\n```\n\n3. 使用新对象调用函数，函数中的this被指向新实例对象\n\n```\nTest.call(obj)\n```\n\n4. 将初始化完毕的新对象地址，保存到等号左边的变量中","tags":["javaScript"]},{"title":"javaScript之attribute和property的区别","url":"/2017/05/30/javaScript之attribute和property的区别/","content":"\n### 1.attribute\n\n#### （attribute是HTML标签上的特性，它的值只能够是字符串；）\n\n```\nAttribute是HTML上设置的属性，在HTML中显式地设置，Attribute就是dom节点自带的属性，例如html中常用的id、class、title、align等。关于这个属性一共有三个相关的方法：setAttribute、getAttribute、removeAttribute；\n```\n\n#### 三种方法的使用\n\n```\n<body>\n    <input type=\"text\" id=\"inpu\" class=\"input\" value=\"123\">\n    <button onclick=\"myfunc()\">转变</button>\n</body>\n<script>\n    var input = document.getElementById('inpu');\n    console.log(input.attributes)\n    function myfunc() {\n    \n        input.setAttribute('type', \"button\");\n        \n        console.log(input.getAttribute('class'));//input\n        \n        input.removeAttribute(\"id\");\n    }\n</script>\n```\n\n### 2.Property\n\n#### (Property是这个DOM元素作为对象，其附加的内容，例如childNodes、firstChild)\n\n```\n<body>\n    <input type=\"text\" id=\"txt\" a='a'>\n    <button onclick=\"myfunc()\">点击</button>\n</body>\n<script>\n    var input = document.getElementById('txt');\n    function myfunc() {\n        console.log(input.type);\n        console.log(input.id);\n        console.log(input.title);//\"\"\n        console.log(input.a);//undefined\n    }\n</script>\n\n我们在html页面的input元素中设置了a属性，但是在property中却是访问不到的；相反我们没有在html页面中设置的title，访问它却没有反映undefined！\n这是怎么回事？\n因为所有的HTML元素都由HTMLElement类型表示，HTMLElement类型直接继承自Element并添加了一些属性，每个HTML元素都有下面的这5个标准特性：id，title，lang，dir，className（在DOM中以property方式操作这几个特性会同步到html标签中）\n```\n\n### 3.二者区别\n\n#####   1.用**点操作符**改变`value`值，并不会更新`attribute`的`value`值；而相反用`attribute`更新`value`值，却会反映到`property`上\n\n```\n var input = document.getElementById('txt');\n    function myfunc() {\n       input.setAttribute('value','test');//test\n       console.log(input.value);\n\n       input.value =\"change\";\n       console.log(input.getAttribute('value'))//test\n    }\n```\n\n##### 2.DOM元素一些默认常见的`attribute`节点都有与之对应的`property`属性，比较特殊的是一些值为`Boolean类型`的`property`，如一些表单元素。对于这些特殊的`attribute`节点，只要存在该节点，对应的`property`的值就为`true`\n\n```\n<body>\n    <input type=\"radio\" checked='checked' id=\"txt\" a='a'>\n    <button onclick=\"myfunc()\">点击</button>\n</body>\n<script>\n    var input = document.getElementById('txt');\n    function myfunc() {\n       console.log(input.getAttribute('checked'))//'checked'\n       console.log(input.checked)//true\n    }\n</script>\n```\n\n##### 3.两者对于`href`的获取也有不同之处，`attribute`取到的是实际设置的值（相对路径），而`property`取得的是绝对路径：\n\n### 4、总结\n\n##### `Attribute`属性在html上设置，会反应在`html`代码上，两者**同步**；\n\n##### Property属性则可以看做是DOM对象的键值对，用**点操作符**对它们进行操作。\n\n实际编程中，基本上的DOM操作都是使用`property`的点操作符。\n\n只有两种情况不得不使用`attribute`：\n\n- 1.自定义HTML Attribute，因为它不能同步到DOM property上\n- 2.访问内置的HTML标签的`Attribute`，这些`attribute`不能从`property`上同步过来，比如`input标签`的`value`值（可以用来检验input值是否变化）","tags":["javaScript"]},{"title":"javaScript之事件有关内容","url":"/2017/05/28/javaScript之事件有关的内容/","content":"\n### 1.事件绑定的方式\n\n```\n<body>\n    <button onclick=\"fun()\">嵌入dom</button>\n    <button id=\"btn\">直接绑定</button>\n    <button id=\"btn1\">事件监听</button>\n</body>\n<script>\n    function fun() {\n        console.log('嵌入dom')\n    }\n    document.getElementById('btn').onclick = function () {\n        console.log('直接绑定')\n    }\n    document.getElementById('btn1').addEventListener('click',function(){\n        console.log('事件监听')\n    })\n</script>\n```\n\n### 2.事件委托\n\n事件委托利用了事件冒泡，将子元素自己的事件交给父亲来处理\n\n```\n<ul>\n  <li>苹果</li>\n  <li>香蕉</li>\n  <li>凤梨</li>\n</ul>\n\n事件委托\ndocument.querySelector('ul').onclick = (event) => {\n  let target = event.target\n  if (target.nodeName === 'LI') {\n    console.log(target.innerHTML)\n  }\n}\n```\n\n### 3.事件循环\n\n事件循环是一个单线程循环，用于将任务队列中的回调函数(任务)调度入栈。如果调用栈中的任务执行完毕并且任务队列中有对应的回调函数(任务)，则将回调函数出队并推送到调用栈中执行。\n\n```\n宏任务：script    setTimeout   setInterval  setImmediate, I/O, UI rendering。\n微任务：process.nextTick, Promise, Object.observe(已废弃), MutationObserver(html5新特性)\n\n事件循环的任务队列有宏任务队列和微任务队列，每次一个宏任务执行完毕的时候，都会把微任务队列中的微任务执行完毕之后才会再次执行下一个宏任务。\n```\n\n### 4.target和currentTarget区别\n\nevent.target：返回触发事件的元素\nevent.currentTarget：返回绑定事件的元素\n\n```\n<body>\n    <ul id=\"box\">\n        <Li id=\"apple\">苹果</Li>\n        <li>香蕉</li>\n        <li>桃子</li>\n    </ul>\n</body>\n<script type=\"text/javascript\">\n    var box = document.getElementById('box');\n    var apple = document.getElementById('apple');\n    //直接绑定在目标元素apple上\n    apple.onclick = function (e) {\n        console.log(e.target);          //<li id=\"apple\">苹果</li>\n        console.log(e.currentTarget);    //<li id=\"apple\">苹果</li>\n        console.log(this);               //<li id=\"apple\">苹果</li>\n        console.log(e.target === e.currentTarget);      //true\n        console.log(e.target === this);           //true\n    }\n    //绑定在父元素box上（如果点击apple这个li时）\n    box.onclick = function (e) {\n        console.log(e.target);           // <li id=\"apple\">苹果</li>\n        console.log(e.currentTarget);       //<ul id=\"box\">...</ul>\n        console.log(this);                  //<ul id=\"box\">...</ul>\n        console.log(e.currentTarget === this);      //true\n        console.log(e.target === e.currentTarget);        //false\n        console.log(e.target === this);           //false\n    }\n\n</script>\n```\n\n### 5.事件冒泡和事件捕获\n\n执行顺序不同\n事件冒泡：事件会从最内层的元素开始发生，一直向上传播，直到document对象。\n事件捕获：事件从最外层开始发生，直到最具体的元素。","tags":["javaScript"]},{"title":"javaScript之函数的节流阀和去抖","url":"/2017/05/26/javaScript之函数的节流阀和去抖/","content":"\n#### 1.函数去抖（debounce）\n\n函数调用n秒后才会执行，如果函数在n秒内被调用的话则函数不执行，重新计算执行时间\n\n```\nfunction debounce(method,delay){\n      var timer=null;\n       return function(){\n            var context=this\n            var args=arguments;\n            clearTimeout(timer);\n            timer=setTimeout(function(){\n                method.apply(context,args);\n            },delay);\n        }\n}\n```\n\n##### 函数去抖的应用场景：\n\n1.监控键盘keypress事件，每当内容变化的时候就向服务器发送请求\n2.在页面滚动的时候监控页面的滚动事件，会频繁执行scroll事件\n3.监控页面的resize事件，拉动窗口改变大小的时候，resize事件被频繁的执行\n\n上面三种场景中都会频繁触发指定事件，比如第一种情况，每当输入框内容变化之后就向服务器发送请求，可能会导致一秒钟向服务器请求很多次，这显然是不合理的，我们可以使用函数去抖来优化。\n\n#### 2.函数节流（throttle）\n\n函数预先设定一个执行周期，当调用动作的时刻大于等于执行周期则执行该动作，然后进入下一个新周期\nfunction throttle(method,duration){\n        var  begin = new Date();\n        return function(){\n            var context = this\n            var args=arguments\n            var current=new Date();\n            if(current-begin>=duration){\n                 method.apply(context,args);\n                 begin = current;\n            }\n        }\n}\nfunction resizehandler(){\n    console.log(++n);\n}\nwindow.onresize=throttle(resizehandler,500);\n\n##### 函数节流的应用场景\n\n1.上拉下拉刷新，每拉动一次彻底完毕之后才可以下一次拉动\n2.图片轮播动画，每一张图片动画完成之后才开始下一个图片的动画\n\n\n\n\n\n\n\n","tags":["javaScript"]},{"title":"javaScript之函数及this指向","url":"/2017/05/24/javaScript之函数及this指向问题/","content":"\n### 1.函数的声明有两种方法：\n\n     //1.命名函数  函数有名字\n        function testMe(){\n    }\n    \n    //2.匿名函数  函数没有实际的名字\n    var a = function(){\n        console.log(\"我是匿名函数\")\n    }\n\n\n\n### 2．自调用函数\n\n```\n1.自调用函数的写法\n(function(){\n\n})()\n\n2.自调用函数的作用：\n开启一个新的作用域，防止变量命名污染的问题(沙箱)\n\n\n3. 在自调用函数中向外部暴露信息\n   (function(w){\n         var k = \"kk\";\n         w.k = k;  //一旦某个变量挂载到window对象中的时候，那么该变量就变成了全局变量\n     })(window)\n\n     console.log(k);\n\n\n4.\t自调用函数注意点\n   我们在写自调用函数的时候，推荐在自调用函数前面加;\n\n;(function(){})()\n;(function(){})()\n;(function(){})()\n```\n\n\n\n    console.log(box.style.width)   //box.style.xx  获取的是行内样式，如果是获取宽度指的是内容的宽度\n    console.log(box.style.height)\n    \n    console.log(box.clientWidth);  //获取的是边框以内的宽度\n    console.log(box.offsetWidth);  //获取的是边框以及边框以内的宽度\n    console.log(box.scrollWidth);  //获取的是滚动出去的距离 + clientWidth\n\n\n\n### 3.this总结:\n\n```\n1.\t普通函数中的this    this是window\n   function a(){\n    console.log(this);\n   }\n   a()\n\n2.\t构造函数中this    this是当前的对象\n   实例方法中的this   this是当前对象\n   function Person(){\n   this.name =name;\n   this.say = function(){\n     console.log(this);\n   }\n   }\n   var p = new Person(){}\n   p.say();\n\n3.\tDom事件中的this   this是绑定事件的那个dom对象\n   div.onclick = function(){\n    console.log(this)\n   }\n\n4.\t定时器中this    this是window\n   setInterval(function(){\n    console.log(this)\n   },1000)\n```\n\n","tags":["javaScript"]},{"title":"javaScript之函数及this指向","url":"/2017/05/24/javaScript之call,apply,bind的区别/","content":"\n### 1.函数的声明有两种方法：\n\n     //1.命名函数  函数有名字\n        function testMe(){\n    }\n    \n    //2.匿名函数  函数没有实际的名字\n    var a = function(){\n        console.log(\"我是匿名函数\")\n    }\n\n\n\n### 2．自调用函数\n\n```\n1.自调用函数的写法\n(function(){\n\n})()\n\n2.自调用函数的作用：\n开启一个新的作用域，防止变量命名污染的问题(沙箱)\n\n\n3. 在自调用函数中向外部暴露信息\n   (function(w){\n         var k = \"kk\";\n         w.k = k;  //一旦某个变量挂载到window对象中的时候，那么该变量就变成了全局变量\n     })(window)\n\n     console.log(k);\n\n\n4.\t自调用函数注意点\n   我们在写自调用函数的时候，推荐在自调用函数前面加;\n\n;(function(){})()\n;(function(){})()\n;(function(){})()\n```\n\n\n\n    console.log(box.style.width)   //box.style.xx  获取的是行内样式，如果是获取宽度指的是内容的宽度\n    console.log(box.style.height)\n    \n    console.log(box.clientWidth);  //获取的是边框以内的宽度\n    console.log(box.offsetWidth);  //获取的是边框以及边框以内的宽度\n    console.log(box.scrollWidth);  //获取的是滚动出去的距离 + clientWidth\n\n\n\n### 3.this总结:\n\n```\n1.\t普通函数中的this    this是window\n   function a(){\n    console.log(this);\n   }\n   a()\n\n2.\t构造函数中this    this是当前的对象\n   实例方法中的this   this是当前对象\n   function Person(){\n   this.name =name;\n   this.say = function(){\n     console.log(this);\n   }\n   }\n   var p = new Person(){}\n   p.say();\n\n3.\tDom事件中的this   this是绑定事件的那个dom对象\n   div.onclick = function(){\n    console.log(this)\n   }\n\n4.\t定时器中this    this是window\n   setInterval(function(){\n    console.log(this)\n   },1000)\n```\n\n","tags":["javaScript"]},{"title":"javaScript之创建对象的方法","url":"/2017/05/10/javaScript之创建对象的方式/","content":"\n### JS中创建对象的方式：\n\n创建对象：只要new了就说明创建对象了\n在计算机编程中有一句话：万物皆对象（除了基本数据类型之外的其他任何类型都是对象）\n\n对象里面有什么东西呢？一个对象拥有两个最基本的信息：属性(标识对象的基本信息)和行为(function)！\n\n### 方法一：字面量：\n\n```\nvar a = {\n   name:”zhangsan”,\n   age:18,\n   song:function(){\n}\n}\n```\n\n\n字面量创建对象的实质是通过new Object()来创建的\n\nb)\tnew Object()来创建对象\n\n```\nvar b = new Object();\nb.name = “zhangsan”;\nb.age = 18;\n\nvar c = new Object();\nc.name = “wangwu”;\nc.age = 19;\n```\n\n\n\n### 方法二：通过工厂函数创建对象 \n\n```\n function createPerson(name,age){\n   var p = new Object();\n   p.name = name;\n   p.age = age;\n   return p;\n}\n\nvar p1 = createPerson(“zhangsan”,123);\nvar p2 = createPerson(“lisi”,13);\n\n好处是创建对象的代码进行了封装了，缺陷是无法判断所创建出来的对象的具体类型\nconsole.log(typeof(p1));    object\n```\n\n\n\n### 方法三：通过构造函数来创建对象\n\n```\nfunction Person(name,age){\n   this.name = name;\n   this.age = age;\n}\n//1.构造函数的函数名的首字母大写\n   //2.构造函数中可以使用this  this就代表当前对象\n   //3.构造函数可以new\n\n   var p1 = new Person(“张三”,12);\n   var p2 = new Person(“李四”,13);\n```\n\n\n  通过构造函数来创建对象的好处是可以通过instanceof或者constructor来查看所创建出来的对象的具体类型\n\n    //instanceof 查看对象否是指定类型的对象，如果是返回true；如果不是返回false\n    console.log(p1 instanceof Person);\n    //看p1的构造器是否是Person，如果p1的构造器是Person的话，说明P1是Person类型的对象\n    console.log(p1.constructor == Person);\n\n  \n\n","tags":["javaScript"]},{"title":"javaScript之数组的常用方法","url":"/2017/05/04/javaScript之数组的常用方法/","content":"\n### 1.Array.map()\n\n此方法是将数组中的每个元素调用一个提供的函数，结果作为一个新的数组返回，并没有改变原来的数组\n\n```\nlet arr = [1, 2, 3, 4, 5]\n    let newArr = arr.map(x => x*2)\n    //arr= [1, 2, 3, 4, 5]   原数组保持不变\n    //newArr = [2, 4, 6, 8, 10] 返回新数组　　\n```\n\n### 2.Array.forEach()\n\n此方法是将数组中的每个元素执行传进提供的函数，没有返回值，注意和map方法区分\n\n```\nlet arr = [1, 2, 3, 4, 5]\n   num.forEach(x => x*2)\n   // arr = [1, 2, 3, 4, 5]  数组改变,注意和map区分\n```\n\n### 3.Array.filter()\n\n此方法是将所有元素进行判断，将满足条件的元素作为一个新的数组返回\n\n```\nlet arr = [1, 2, 3, 4, 5]\n    const isBigEnough = value = value >= 3\n    let newArr = arr.filter(isBigEnough )\n    //newNum = [3, 4, 5] 满足条件的元素返回为一个新的数组　\n```\n\n### 4.Array.every()\n\n此方法是将所有元素进行判断返回一个布尔值，如果所有元素都满足判断条件，则返回true，否则为false：\n\n```\nlet arr = [1, 2, 3, 4, 5]\n    const isLessThan4 = value => value < 4\n    const isLessThan6 => value => value < 6\n    arr.every(isLessThan4 ) //false\n    arr.every(isLessThan6 ) //true　　\n```\n\n### 5.Array.some()\n\n 此方法是将所有元素进行判断返回一个布尔值，如果存在元素都满足判断条件，则返回true，若所有元素都不满足判断条件，则返回false：\n\n```\nlet arr= [1, 2, 3, 4, 5]\n    const isLessThan4 = value => value < 4\n    const isLessThan6 = value => value > 6\n    arr.some(isLessThan4 ) //true\n    arr.some(isLessThan6 ) //false　　\n```\n\n### 6.Array.reduce()\n\n 此方法是所有元素调用返回函数，返回值为最后结果,传入的值必须是函数类型：\n\n```\nlet arr = [1, 2, 3, 4, 5]\n   const add = (a, b) => a + b\n   let sum = arr.reduce(add)\n   //sum = 15  相当于累加的效果\n   与之相对应的还有一个 Array.reduceRight() 方法，区别是这个是从右向左操作的　\n```\n\n### 7.Array.push()\n\n 此方法是在数组的后面添加新加元素，此方法改变了数组的长度：\n\n### 8.Array.pop()\n\n 此方法在数组后面删除最后一个元素，并返回数组，此方法改变了数组的长度：\n\n```\nlet arr = [1, 2, 3, 4, 5]\n    arr.pop()\n    console.log(arr) //[1, 2, 3, 4]\n    console.log(arr.length) //4\n```\n\n### 9.Array.shift()\n\n 此方法在数组后面删除第一个元素，并返回数组，此方法改变了数组的长度：\n\n```\nlet arr = [1, 2, 3, 4, 5]\n    arr.shift()\n    console.log(arr) //[2, 3, 4, 5]\n    console.log(arr.length) //4 \n```\n\n### 10.Array.unshift()\n\n 此方法是将一个或多个元素添加到数组的开头，并返回新数组的长度：\n\n```\nlet arr = [1, 2, 3, 4, 5]\n    arr.unshift(6, 7)\n    console.log(arr) //[6, 7, 1, 2, 3, 4, 5]\n    console.log(arr.length) //7 \n```\n\n### 11.Array.isArray()\n\n 判断一个对象是不是数组，返回的是布尔值\n\n### 12.Array.concat()\n\n 此方法是一个可以将多个数组拼接成一个数组：\n\n```\nlet arr1 = [1, 2, 3]\n      arr2 = [4, 5]\n  let arr = arr1.concat(arr2)\n  console.log(arr)//[1, 2, 3, 4, 5]　\n```\n\n### 13.Array.toString()\n\n 此方法将数组转化为字符串：\n\n```\nlet arr = [1, 2, 3, 4, 5];\n   let str = arr.toString()\n   console.log(str)// 1,2,3,4,5　　\n```\n\n### 14.Array.join()\n\n  此方法也是将数组转化为字符串：\n\n```\nlet arr = [1, 2, 3, 4, 5];\n   let str1 = arr.toString()\n   let str2 = arr.toString(',')\n   let str3 = arr.toString('##')\n   console.log(str1)// 12345\n   console.log(str2)// 1,2,3,4,5\n   console.log(str3)// 1##2##3##4##5　　\n```\n\n通过例子可以看出和toString的区别，可以设置元素之间的间隔~ 　　\n\n### 15.Array.splice(开始位置， 删除的个数，元素)\n\n 万能方法，可以实现增删改：\n\n```\nlet arr = [1, 2, 3, 4, 5];\n     let arr1 = arr.splice(2, 0 'haha')\n     let arr2 = arr.splice(2, 3)\n     let arr1 = arr.splice(2, 1 'haha')\n     console.log(arr1) //[1, 2, 'haha', 3, 4, 5]新增一个元素\n     console.log(arr2) //[1, 2] 删除三个元素\n     console.log(arr3) //[1, 2, 'haha', 4, 5] 替换一个元素\n```\n\n","tags":["javaScript"]},{"title":"css之block,inline-block,inlien的区别","url":"/2016/12/05/css之block，inline-block，inline的区别/","content":"\n### 1.inline\n\ninline：使元素变成行内元素（内联），拥有行内元素的特性，即\n\n1. 与其他行内元素共享一行\n2. 不能修改width、height属性，大小由内容撑开\n3. padding属性 top、right、bottom、left设置都有效；margin属性只有left、right设置有效\n4. 可以设置verticle-align\n\n###  2.block\n\nblock： 使元素变成块级元素，拥有块级的特性，即\n\n1. 独占一行，在不设置自己的宽度的情况下，块级元素会默认填满父级元素的宽度\n2. 可以修改width、height属性\n3. padding、margin四个方向的值设置均有效\n4. 不可以设置verticle-align\n\n###  3.inline-block\n\n inline-block： 使元素变成行内块级元素，结合了行内元素和块级元素的特性（不独占一行的块级元素），即\n\n1. 与其他行内元素共享一行\n2. 可以修改width、height属性\n3. padding、margin四个方向的值设置均有效\n4. 可以设置verticle-align\n\n### 4.行内元素、块级元素区别\n\n行内元素：在一行显示，不可以设置宽高。代表  span   a   select  strong br\n\n块级元素：换行显示，可以设置宽高。代表  div  ul  ol  h1-h6  table\n\n行内块级元素：在一行显示，可以设置宽高。代表 img  input","tags":["css"]},{"title":"css之BFC的定义及其作用","url":"/2016/11/28/css之BFC的定义以及其作用/","content":"\n####   1.BFC的定义\n\n​    BFC即 Block Formatting Contexts (块级格式化上下文)， 是 [W3C](https://www.leiue.com/tags/w3c) [CSS](https://www.leiue.com/tags/css)2.1 规范中的一个概念。它是页面中的一块渲染区域，并且有一套渲染规则，它决定了其子元素将如何定位，以及和其他元素的关系和相互作用。\n\n#### 2.BFC的创建\n\n1. 根元素或其它包含它的元素\n2. 浮动元素 (元素的 float 不是 none)\n3. 绝对定位元素 (元素具有 position 为 absolute 或 fixed)\n4. 内联块 (元素具有 display: inline-block)\n5. 表格单元格 (元素具有 display: table-cell，HTML表格单元格默认属性)\n6. 表格标题 (元素具有 display: table-caption, HTML表格标题默认属性)\n7. 具有overflow 且值不是 visible 的块元素，\n8. display: flow-root\n9. column-span: all 应当总是会创建一个新的格式化上下文，即便具有 column-span: all 的元素并不被包裹在一个多列容器中。\n10. 一个块格式化上下文包括创建它的元素内部所有内容，除了被包含于创建新的块级格式化上下文的后代元素内的元素。\n\n#### 3.BFC布局规则\n\n   1.内部的Box会在垂直方向，一个接一个的放置\n   2.Box的垂直方向的距离由margin决定，属于同一个BFC的两个相邻的Box会重叠\n   3.BFC的区域不会与float box重叠（定位情况除外）\n   4.计算BFC的高度时，浮动元素也参与计算\n   5.BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。反之也如此\n\n####  4.BFC作用：\n\n1、解决 margin 塌陷问题\n\n​      margin塌陷问题：在标准文档流中，块级标签之间竖直方向的margin会以大的为准\n\n```\n<head>\ndiv{\n    width: 100px;\n    height: 100px;\n    background: lightblue;\n    margin: 100px;\n}\n</head>\n<body>\n    <div></div>\n    <div></div>\n</body>\n注意：两个div竖直之间的距离为100px\n```\n\n如果想要避免外边距的重叠，可以将其放在不同的 BFC 容器中\n\n```\n <div class=\"container\">\n    <p></p>\n </div>\n <div class=\"container\">\n    <p></p>\n </div>\n \n \n .container {\n    overflow: hidden;\n}\np {\n    width: 100px;\n    height: 100px;\n    background: lightblue;\n    margin: 100px;\n} \n    \n```\n\n2、避免浮动元素和其他元素重叠\n\n​     div浮动兄弟遮盖问题：左侧块级元素发生了浮动，所以和右侧未发生浮动的块级元素不在同一层内，所以会发生左边div遮挡下面的div。可以给下面div加 overflow: hidden，触发bfc来解决遮挡问题。 \n\n3、清除浮动\n\n```\n.fahter{   \n   width: 400px; \n   border: 1px solid deeppink;\n   overflow: hidden;  \n}\n```","tags":["css"]},{"title":"css之水平垂直居中的四种方法","url":"/2016/11/22/css之水平垂直居中的四种方法/","content":"\n####   1.flex\n\n```\n .father {\n            display: flex;\n            justify-content: center;\n            align-items: center;\n            width: 50px;\n            height:50px;\n            border:1px solid black;\n        }\n        .son{\n            width: 30px;\n            height: 30px;\n            border: 1px solid red;\n        }\n        \n  <div class=\"father\">\n      <div class=\"son\"></div>\n  </div>\n```\n\n#### 2.position\n\n```\n .father {\n            position: relative;\n            width: 50px;\n            height: 50px;\n            border: 1px solid black;\n        }\n        .son {\n            position: absolute;\n            margin: auto;\n            top: 0;\n            bottom: 0;\n            left: 0;\n            right: 0;\n            width: 30px;\n            height: 30px;\n            border: 1px solid red;\n        }\n```\n\n\n\n#### 3.position+transform\n\n```\n.father {\n            position: relative;\n            width: 50px;\n            height: 50px;\n            border: 1px solid black;\n        }\n        .son {\n            position: absolute;\n            top: 50%;\n            left: 50%;\n            transform: translate(-50%, -50%);\n            width: 30px;\n            height: 30px;\n            border: 1px solid red;\n        }\n```\n\n\n\n####  4.table-cell\n\n```\n<style>\n        html,\n        body {\n            height: 100%;\n            width: 100%;\n            margin: 0;\n        }\n\n        .box {\n            display: table;\n            height: 100%;\n            width: 100%;\n        }\n\n        .content {\n            display: table-cell;\n            vertical-align: middle;\n            text-align: center;\n        }\n\n        .inner {\n            background-color: #000;\n            display: inline-block;\n            width: 200px;\n            height: 200px;\n        }\n    </style>\n   \n     <div class=\"box\">\n        <div class=\"content\">\n            <div class=\"inner\"></div>\n        </div>\n    </div>\n```\n\n  \n\n","tags":["css"]},{"title":"动画demo通过github访问","url":"/2016/11/20/动画demo通过github搭建访问/","content":"\n#### **1.**  新建一个远程仓库\n\n![img](/img/01/wps1.jpg) \n\n#### 2. 在animations仓库setting中随意选择一个主题\n\n![img](/img/01/wps2.jpg) \n\n#### 3. 通过仓库的首页\n\n   通过 https://smallantcxq.github.io/animations/可访问：\n\n![img](/img/01/wps3.jpg) \n\n\n\n如下：\n\n![img](/img/01/wps4.jpg) \n\n#### 4. 在本地创建文件夹空文件夹（animat）映射仓库\n\n 在animat中打开git Bash命令行\n\ngit clone git@github.com:smallAntcxq/animations.git\n\n#### 5. 删除animat中的除.git文件外的所有文件(.git为隐藏文件)\n\n在此路径下执行\n\n$ git add *\n\n$ git commit -m 'del'\n\n$ git push origin master\n\n这时执行 https://smallantcxq.github.io/animations/显示404\n\n#### 6. 在animations中加入想要展示的页面\n\n![img](/img/01/wps5.jpg) \n\n执行：\n\n$ git add *\n\n$ git commit -m 'del'\n\n$ git push origin master\n\n#### 7. 结果为：\n\n![img](/img/01/wps6.jpg)\n\n#### 8. 这时通过以下可访问\n\nhttps://smallantcxq.github.io/animations/3d.html\n\nhttps://smallantcxq.github.io/animations/sky.html\n\nhttps://smallantcxq.github.io/animations/game.html","tags":["搭建步骤"]},{"title":"css之浮动的定义及清除浮动的方法","url":"/2016/11/10/css之浮动的定义以及清除浮动的方法/","content":"\n####   1.浮动的定义\n\n定义：使元素脱离文档流，按照指定的方向发生移动，遇到父级的边界或者相邻的浮动元素就会停下来.\n\n浮动的目的：为了达到自己的布局目的，让指定元素定位在指定位置，并且可以设置浮动后的行级元素的宽高，我们就需要用到浮动\n\n#### 2.为什么要清除浮动\n\n   清除浮动主要是为了解决，父元素因为子级元素浮动引起的内部高度为0的问题\n\n   原因：当父元素不给高度的时候，内部元素不浮动时会撑开，而浮动的时候，父元素变成一条线。\n\n#### 3.清除浮动的常用方法\n\n   （1）加空div（在最后一个浮动标签后，新加一个标签，给其设置clear：both；）（不推荐）\n\n```\n<div class=\"fahter\">\n      <div class=\"big\">big</div>\n      <div class=\"small\">small</div>\n      <div class=\"clear\">额外标签法</div>\n </div>\n```\n\n   （2）父级添加overflow属性（父元素添加overflow:hidden）（不推荐）\n\n```html\n .fahter{   \n   width: 400px; \n   border: 1px solid deeppink;\n   overflow: hidden;  \n}\n```\n\n  （3）父级使用after伪元素清除浮动（推荐使用）\n\n```html\n .clearfix:after{/*伪元素是行内元素 正常浏览器清除浮动方法*/\n        content: \"\";\n        display: block;\n        height: 0;\n        clear:both;\n        visibility: hidden;\n    }\n```\n\n  （4）使用before和after双伪元素清除浮动\n\n```html\n  .clearfix:after,.clearfix:before{\n        content: \"\";\n        display: table;\n    }\n    .clearfix:after{\n        clear: both;\n    }\n    .clearfix{\n        *zoom: 1;\n    }\n \n <div class=\"fahter clearfix\">\n        <div class=\"big\">big</div>\n        <div class=\"small\">small</div>\n    </div>\n    <div class=\"footer\"></div>\n```","tags":["css"]}]